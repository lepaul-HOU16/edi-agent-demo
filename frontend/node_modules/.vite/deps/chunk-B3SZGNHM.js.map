{
  "version": 3,
  "sources": ["../../../../node_modules/@cloudscape-design/component-toolkit/container-queries/use-container-query.js", "../../../../node_modules/@cloudscape-design/component-toolkit/use-controllable-state/use-controllable-state.js"],
  "sourcesContent": ["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useRef, useState, useCallback } from 'react';\nimport { useResizeObserver } from '../internal/container-queries/use-resize-observer';\n/**\n * Attaches resize-observer to the referenced element and keeps last observation in state.\n * The hook allows to limit the amount of re-renders to only when the observed value changes.\n *\n * @example\n * Switching display mode under a given condition (only re-renders when mode changes):\n * ```\n * const [smallMode, ref] = useContainerQuery(entry => entry.contentBoxHeight <= smallModeHeight, [smallModeHeight])\n * ```\n *\n * @example\n * Obtaining observer entry (re-renders with each observation):\n * ```\n * const [entry, ref] = useContainerQuery(entry => entry)\n * ```\n *\n * @example\n * Using previous state to avoid unnecessary re-renders:\n * ```\n * const [value, ref] = useContainerQuery((entry, prev) => shouldUpdate(entry) ? getValue(entry) : prev)\n * ```\n *\n * @typeParam ObservedState State obtained from the last observation\n * @param mapFn Function to convert ContainerQueryEntry to ObservedState\n * @param deps Dependency list to indicate when the mapFn changes\n * @returns A tuple of the observed state and a reference to be attached to the target element\n */\nexport default function useContainerQuery(mapFn, deps = []) {\n    const elementRef = useRef(null);\n    const [state, setState] = useState(null);\n    // Update getElement when deps change to trigger new observation.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    const getElement = useCallback(() => elementRef.current, deps);\n    useResizeObserver(getElement, entry => setState(prevState => mapFn(entry, prevState)));\n    return [state, elementRef];\n}\n", "// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useState, useEffect, useCallback } from 'react';\nimport { useStableCallback } from '../internal/stable-callback';\nimport { isDevelopment } from '../internal/is-development';\nimport { warnOnce } from '../internal/logging';\n/**\n * This hook allows you to make a component that can be used both in controlled\n * mode and uncontrolled mode. Pass in your component's props, and then implement\n * your component as if it was only controlled.\n *\n * A component determines its mode (either controlled or uncontrolled) on the\n * first render and keeps it for its lifetime. The mode cannot be switched later.\n *\n * @example\n * Using useControllableState in a custom checkbox component\n * ```\n * const [checked, setChecked] = useControllable(\n *   props.checked,\n *   props.onChange,\n *   props.defaultEnabled ?? false,\n *   {\n *     componentName: 'MyCheckboxComponent',\n *     propertyName: 'checked',\n *     changeHandler: 'onChange'\n *   }\n * );\n *\n * return (\n *   <input\n *     type=\"checkbox\"\n *     checked={checked}\n *     onChange={event => setChecked(event.target.checked)}\n *   />\n * );\n * ```\n *\n * @param controlledValue The value to use for controlled mode\n * @param changeHandler The update handler for controlled mode\n * @param defaultValue The initial value for uncontrolled mode\n * @param propertyDescriptions Property names used when emitting warnings\n * @param fireEvent Callback executed when controllable value changes\n * @returns A tuple of value and value setter\n */\nexport default function useControllable(controlledValue, changeHandler, defaultValue, propertyDescriptions, fireEvent = (value, handler) => handler(value)) {\n    const { componentName, changeHandlerName, propertyName } = propertyDescriptions;\n    // The decision whether a component is controlled or uncontrolled is made on\n    // its first render and cannot be changed afterwards.\n    const [isControlled] = useState(controlledValue !== undefined);\n    // Most build tools will just strip this block from production builds, so we can\n    // skip the conditional hook lint error.\n    if (isDevelopment) {\n        // Print a warning if a controlled property was passed in without a change handler.\n        // This may fire every render if the change handler isn't memoized, but warnOnce\n        // will dedupe the error messages.\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        useEffect(() => {\n            if (isControlled && changeHandler === undefined) {\n                warnOnce(componentName, `You provided a \\`${propertyName}\\` prop without an \\`${changeHandlerName}\\` handler. This will render a non-interactive component.`);\n            }\n        }, [changeHandler, isControlled, componentName, changeHandlerName, propertyName]);\n        // Print a warning if the component switches between controlled and uncontrolled mode.\n        const isControlledValueProvided = controlledValue !== undefined;\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        useEffect(() => {\n            if (isControlled !== isControlledValueProvided) {\n                const initialMode = isControlled ? 'controlled' : 'uncontrolled';\n                const modeNow = isControlledValueProvided ? 'controlled' : 'uncontrolled';\n                warnOnce(componentName, `A component tried to change ${initialMode} '${propertyName}' property to be ${modeNow}. ` +\n                    `This is not supported. Properties should not switch from ${initialMode} to ${modeNow} (or vice versa). ` +\n                    `Decide between using a controlled or uncontrolled mode for the lifetime of the component. ` +\n                    `More info: https://fb.me/react-controlled-components`);\n            }\n        }, [isControlled, isControlledValueProvided, propertyName, componentName]);\n    }\n    // This is the value that is used if the component is uncontrolled.\n    const [valueState, setValue] = useState(defaultValue);\n    const [isUncontrolledValueSet, setIsUncontrolledValueSet] = useState(false);\n    const stableFireEvent = useStableCallback((value, handler) => fireEvent(value, handler));\n    const setControlledValue = useCallback((value) => {\n        if (changeHandler) {\n            stableFireEvent(value, changeHandler);\n        }\n    }, [changeHandler, stableFireEvent]);\n    // We allow changes to the defaultValue prop to be reflected until the component\n    // starts controlling it internally.\n    const currentUncontrolledValue = isUncontrolledValueSet ? valueState : defaultValue;\n    const setUncontrolledValue = useCallback((newValue) => {\n        setValue(newValue);\n        setIsUncontrolledValueSet(true);\n    }, []);\n    return isControlled ? [controlledValue, setControlledValue] : [currentUncontrolledValue, setUncontrolledValue];\n}\n"],
  "mappings": ";;;;;;;;;;;AAEA,mBAA8C;AA6B/B,SAAR,kBAAmC,OAAO,OAAO,CAAC,GAAG;AACxD,QAAM,iBAAa,qBAAO,IAAI;AAC9B,QAAM,CAAC,OAAO,QAAQ,QAAI,uBAAS,IAAI;AAGvC,QAAM,iBAAa,0BAAY,MAAM,WAAW,SAAS,IAAI;AAC7D,oBAAkB,YAAY,WAAS,SAAS,eAAa,MAAM,OAAO,SAAS,CAAC,CAAC;AACrF,SAAO,CAAC,OAAO,UAAU;AAC7B;;;ACrCA,IAAAA,gBAAiD;",
  "names": ["import_react"]
}
