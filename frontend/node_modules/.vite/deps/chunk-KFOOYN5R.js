import {
  Transition_default
} from "./chunk-WAJJAPY2.js";
import {
  InternalSpinner,
  useModalContextLoadingButtonComponent
} from "./chunk-QUGP2XCS.js";
import {
  fireCancelableEvent,
  isPlainLeftClick,
  useForwardFocus
} from "./chunk-VOJL5FZQ.js";
import {
  internal_default,
  internal_default2,
  useInternalI18n
} from "./chunk-MPPGLDEP.js";
import {
  isDevelopment
} from "./chunk-CCBYTID7.js";
import {
  calculateScroll,
  getFirstScrollableParent,
  scrollRectangleIntoView
} from "./chunk-G4E5S7N7.js";
import {
  useModalContext
} from "./chunk-XQ7LOIJ7.js";
import {
  DATA_ATTR_FUNNEL_VALUE,
  FunnelMetrics,
  findUpUntilMultiple,
  getFunnelValueSelector,
  getSubStepAllSelector,
  getTextFromSelector,
  isContainingBlock,
  nodeBelongs,
  useFunnel,
  useFunnelStep,
  useFunnelSubStep
} from "./chunk-3YAZCWEI.js";
import {
  useMergeRefs
} from "./chunk-3AQDIJNT.js";
import {
  getAnalyticsLabelAttribute,
  getAnalyticsMetadataAttribute,
  useRandomId,
  useUniqueId
} from "./chunk-UO4K3KY5.js";
import {
  clsx_m_default,
  getLogicalBoundingClientRect,
  nodeContains,
  useReducedMotion,
  useResizeObserver,
  useVisualRefresh,
  warnOnce
} from "./chunk-TACQRHRS.js";
import {
  __rest
} from "./chunk-FA3WS4TG.js";
import {
  require_react_dom
} from "./chunk-IOW5GAHV.js";
import {
  require_react
} from "./chunk-NNXGX6WR.js";
import {
  __toESM
} from "./chunk-WOOG5QLI.js";

// ../node_modules/@cloudscape-design/components/internal/utils/check-safe-url.js
var allowedJavascriptUrls = ["javascript:void(0)", "javascript:void(0);", "javascript:;"];
function checkSafeUrl(component, url) {
  if (!url) {
    return;
  }
  if (allowedJavascriptUrls.indexOf(url.toLowerCase()) !== -1) {
    return;
  }
  let parsedUrl;
  try {
    parsedUrl = new URL(url);
  } catch (e) {
    return;
  }
  if (parsedUrl.protocol === "javascript:") {
    warnOnce(component, `A javascript: URL was blocked as a security precaution. The URL was "${url}".`);
    throw new Error(`A javascript: URL was blocked as a security precaution.`);
  }
  return;
}

// ../node_modules/@cloudscape-design/components/button/internal.js
var import_react17 = __toESM(require_react());

// ../node_modules/@cloudscape-design/components/internal/components/tooltip/index.js
var import_react10 = __toESM(require_react());

// ../node_modules/@cloudscape-design/components/popover/arrow.js
var import_react = __toESM(require_react());

// ../node_modules/@cloudscape-design/components/popover/styles.css.js
import "/Users/cmgabri/Desktop/osdu-decoupled/frontend-uxpin/node_modules/@cloudscape-design/components/popover/styles.scoped.css";
var styles_css_default = {
  "arrow": "awsui_arrow_xjuzf_t5apl_289",
  "arrow-outer": "awsui_arrow-outer_xjuzf_t5apl_293",
  "arrow-inner": "awsui_arrow-inner_xjuzf_t5apl_293",
  "arrow-position-right-top": "awsui_arrow-position-right-top_xjuzf_t5apl_335",
  "arrow-position-right-bottom": "awsui_arrow-position-right-bottom_xjuzf_t5apl_335",
  "arrow-position-left-top": "awsui_arrow-position-left-top_xjuzf_t5apl_338",
  "arrow-position-left-bottom": "awsui_arrow-position-left-bottom_xjuzf_t5apl_338",
  "arrow-position-top-center": "awsui_arrow-position-top-center_xjuzf_t5apl_341",
  "arrow-position-top-right": "awsui_arrow-position-top-right_xjuzf_t5apl_341",
  "arrow-position-top-left": "awsui_arrow-position-top-left_xjuzf_t5apl_341",
  "arrow-position-top-responsive": "awsui_arrow-position-top-responsive_xjuzf_t5apl_341",
  "arrow-position-bottom-center": "awsui_arrow-position-bottom-center_xjuzf_t5apl_344",
  "arrow-position-bottom-right": "awsui_arrow-position-bottom-right_xjuzf_t5apl_344",
  "arrow-position-bottom-left": "awsui_arrow-position-bottom-left_xjuzf_t5apl_344",
  "arrow-position-bottom-responsive": "awsui_arrow-position-bottom-responsive_xjuzf_t5apl_344",
  "body": "awsui_body_xjuzf_t5apl_492",
  "body-overflow-visible": "awsui_body-overflow-visible_xjuzf_t5apl_528",
  "has-dismiss": "awsui_has-dismiss_xjuzf_t5apl_532",
  "dismiss": "awsui_dismiss_xjuzf_t5apl_537",
  "dismiss-control": "awsui_dismiss-control_xjuzf_t5apl_545",
  "header-row": "awsui_header-row_xjuzf_t5apl_549",
  "header": "awsui_header_xjuzf_t5apl_549",
  "content": "awsui_content_xjuzf_t5apl_574",
  "content-overflow-visible": "awsui_content-overflow-visible_xjuzf_t5apl_582",
  "container": "awsui_container_xjuzf_t5apl_730",
  "container-arrow-position-bottom-left": "awsui_container-arrow-position-bottom-left_xjuzf_t5apl_741",
  "container-arrow-position-bottom-center": "awsui_container-arrow-position-bottom-center_xjuzf_t5apl_741",
  "container-arrow-position-bottom-right": "awsui_container-arrow-position-bottom-right_xjuzf_t5apl_741",
  "container-arrow-position-top-left": "awsui_container-arrow-position-top-left_xjuzf_t5apl_746",
  "container-arrow-position-top-center": "awsui_container-arrow-position-top-center_xjuzf_t5apl_746",
  "container-arrow-position-top-right": "awsui_container-arrow-position-top-right_xjuzf_t5apl_746",
  "container-arrow-position-right-top": "awsui_container-arrow-position-right-top_xjuzf_t5apl_751",
  "container-arrow-position-right-bottom": "awsui_container-arrow-position-right-bottom_xjuzf_t5apl_751",
  "container-arrow-position-left-top": "awsui_container-arrow-position-left-top_xjuzf_t5apl_756",
  "container-arrow-position-left-bottom": "awsui_container-arrow-position-left-bottom_xjuzf_t5apl_756",
  "container-body": "awsui_container-body_xjuzf_t5apl_762",
  "container-body-variant-annotation": "awsui_container-body-variant-annotation_xjuzf_t5apl_802",
  "container-body-size-small": "awsui_container-body-size-small_xjuzf_t5apl_807",
  "fixed-width": "awsui_fixed-width_xjuzf_t5apl_810",
  "container-body-size-medium": "awsui_container-body-size-medium_xjuzf_t5apl_814",
  "container-body-size-large": "awsui_container-body-size-large_xjuzf_t5apl_821",
  "container-arrow": "awsui_container-arrow_xjuzf_t5apl_741",
  "container-arrow-position-top-responsive": "awsui_container-arrow-position-top-responsive_xjuzf_t5apl_871",
  "awsui-motion-fade-in": "awsui_awsui-motion-fade-in_xjuzf_t5apl_1",
  "refresh": "awsui_refresh_xjuzf_t5apl_1065",
  "root": "awsui_root_xjuzf_t5apl_1087",
  "no-wrap": "awsui_no-wrap_xjuzf_t5apl_1119",
  "root-filtering-token": "awsui_root-filtering-token_xjuzf_t5apl_1123",
  "trigger": "awsui_trigger_xjuzf_t5apl_1127",
  "overflow-ellipsis": "awsui_overflow-ellipsis_xjuzf_t5apl_1134",
  "trigger-type-text-inline": "awsui_trigger-type-text-inline_xjuzf_t5apl_1142",
  "trigger-type-text": "awsui_trigger-type-text_xjuzf_t5apl_1142",
  "trigger-type-filtering-token": "awsui_trigger-type-filtering-token_xjuzf_t5apl_1210",
  "popover-inline-content": "awsui_popover-inline-content_xjuzf_t5apl_1214"
};

// ../node_modules/@cloudscape-design/components/popover/arrow.js
var Arrow = (props) => {
  const isVisualRefresh = useVisualRefresh();
  return import_react.default.createElement(
    "div",
    { className: clsx_m_default(styles_css_default.arrow, props.position && styles_css_default[`arrow-position-${props.position}`]) },
    import_react.default.createElement("div", { className: styles_css_default["arrow-outer"] }),
    import_react.default.createElement("div", { className: clsx_m_default(styles_css_default["arrow-inner"], isVisualRefresh && styles_css_default.refresh) })
  );
};
var arrow_default = import_react.default.memo(Arrow);

// ../node_modules/@cloudscape-design/components/popover/body.js
var import_react4 = __toESM(require_react());

// ../node_modules/@cloudscape-design/components/internal/components/focus-lock/index.js
var import_react3 = __toESM(require_react());

// ../node_modules/@cloudscape-design/components/internal/components/tab-trap/index.js
var import_react2 = __toESM(require_react());

// ../node_modules/@cloudscape-design/components/internal/components/tab-trap/styles.css.js
import "/Users/cmgabri/Desktop/osdu-decoupled/frontend-uxpin/node_modules/@cloudscape-design/components/internal/components/tab-trap/styles.scoped.css";
var styles_css_default2 = {
  "root": "awsui_root_oip5a_160mh_5"
};

// ../node_modules/@cloudscape-design/components/internal/components/tab-trap/index.js
function TabTrap({ focusNextCallback, disabled = false }) {
  return import_react2.default.createElement("div", { className: styles_css_default2.root, tabIndex: disabled ? -1 : 0, onFocus: focusNextCallback });
}

// ../node_modules/@cloudscape-design/components/internal/components/focus-lock/utils.js
var tabbables = [
  "button:enabled",
  "select:enabled",
  "textarea:enabled",
  "input:enabled",
  "a[href]",
  "area[href]",
  "summary",
  "iframe",
  "object",
  "embed",
  "audio[controls]",
  "video[controls]",
  "[tabindex]",
  "[contenteditable]",
  "[autofocus]"
].join(",");
function getAllFocusables(container) {
  return Array.prototype.slice.call(container.querySelectorAll(tabbables));
}
function getFocusables(container) {
  return getAllFocusables(container).filter((element) => element.tabIndex !== -1);
}
function getFirstFocusable(container) {
  var _a;
  const focusables = getFocusables(container);
  return (_a = focusables[0]) !== null && _a !== void 0 ? _a : null;
}
function getLastFocusable(container) {
  var _a;
  const focusables = getFocusables(container);
  return (_a = focusables[focusables.length - 1]) !== null && _a !== void 0 ? _a : null;
}

// ../node_modules/@cloudscape-design/components/internal/components/focus-lock/index.js
function FocusLock({ className, disabled, autoFocus, restoreFocus, children }, ref) {
  const returnFocusToRef = (0, import_react3.useRef)(null);
  const containerRef = (0, import_react3.useRef)(null);
  const focusFirst = () => {
    var _a;
    if (containerRef.current) {
      (_a = getFirstFocusable(containerRef.current)) === null || _a === void 0 ? void 0 : _a.focus();
    }
  };
  const focusLast = () => {
    var _a;
    if (containerRef.current) {
      (_a = getLastFocusable(containerRef.current)) === null || _a === void 0 ? void 0 : _a.focus();
    }
  };
  (0, import_react3.useEffect)(() => {
    if (autoFocus && !disabled) {
      returnFocusToRef.current = document.activeElement;
      focusFirst();
    }
  }, [autoFocus, disabled]);
  const [previouslyDisabled, setPreviouslyDisabled] = (0, import_react3.useState)(!!disabled);
  (0, import_react3.useEffect)(() => {
    var _a;
    if (previouslyDisabled !== !!disabled) {
      setPreviouslyDisabled(!!disabled);
      if (restoreFocus && disabled) {
        (_a = returnFocusToRef.current) === null || _a === void 0 ? void 0 : _a.focus();
        returnFocusToRef.current = null;
      }
    }
  }, [previouslyDisabled, disabled, restoreFocus]);
  const restoreFocusHandler = (0, import_react3.useCallback)((elem) => {
    var _a;
    if (elem === null && restoreFocus) {
      (_a = returnFocusToRef.current) === null || _a === void 0 ? void 0 : _a.focus();
      returnFocusToRef.current = null;
    }
  }, [restoreFocus]);
  (0, import_react3.useImperativeHandle)(ref, () => ({ focusFirst }));
  const mergedRef = useMergeRefs(containerRef, restoreFocusHandler);
  return import_react3.default.createElement(
    import_react3.default.Fragment,
    null,
    import_react3.default.createElement(TabTrap, { disabled, focusNextCallback: focusLast }),
    import_react3.default.createElement("div", { className, ref: mergedRef }, children),
    import_react3.default.createElement(TabTrap, { disabled, focusNextCallback: focusFirst })
  );
}
var focus_lock_default = import_react3.default.forwardRef(FocusLock);

// ../node_modules/@cloudscape-design/components/internal/keycode.js
var KeyCode;
(function(KeyCode2) {
  KeyCode2[KeyCode2["pageUp"] = 33] = "pageUp";
  KeyCode2[KeyCode2["pageDown"] = 34] = "pageDown";
  KeyCode2[KeyCode2["end"] = 35] = "end";
  KeyCode2[KeyCode2["home"] = 36] = "home";
  KeyCode2[KeyCode2["backspace"] = 8] = "backspace";
  KeyCode2[KeyCode2["space"] = 32] = "space";
  KeyCode2[KeyCode2["down"] = 40] = "down";
  KeyCode2[KeyCode2["left"] = 37] = "left";
  KeyCode2[KeyCode2["right"] = 39] = "right";
  KeyCode2[KeyCode2["up"] = 38] = "up";
  KeyCode2[KeyCode2["escape"] = 27] = "escape";
  KeyCode2[KeyCode2["enter"] = 13] = "enter";
  KeyCode2[KeyCode2["tab"] = 9] = "tab";
})(KeyCode || (KeyCode = {}));

// ../node_modules/@cloudscape-design/components/popover/body.js
function PopoverBody({ dismissButton: showDismissButton, dismissAriaLabel, header, children, onDismiss, variant, overflowVisible, className, ariaLabelledby, closeAnalyticsAction }) {
  const i18n = useInternalI18n("popover");
  const labelledById = useUniqueId("awsui-popover-");
  const dismissButtonFocused = (0, import_react4.useRef)(false);
  const dismissButtonRef = (0, import_react4.useRef)(null);
  const onKeyDown = (0, import_react4.useCallback)((event) => {
    if (event.keyCode === KeyCode.escape) {
      event.stopPropagation();
      onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss();
    }
  }, [onDismiss]);
  (0, import_react4.useEffect)(() => {
    var _a;
    if (showDismissButton && !dismissButtonFocused.current) {
      (_a = dismissButtonRef.current) === null || _a === void 0 ? void 0 : _a.focus({ preventScroll: true });
    }
    dismissButtonFocused.current = showDismissButton;
  }, [showDismissButton]);
  const dismissButton = (showDismissButton !== null && showDismissButton !== void 0 ? showDismissButton : null) && import_react4.default.createElement(
    "div",
    Object.assign({ className: styles_css_default.dismiss }, closeAnalyticsAction ? getAnalyticsMetadataAttribute({ action: closeAnalyticsAction }) : {}),
    import_react4.default.createElement(InternalButton, { variant: "icon", formAction: "none", iconName: "close", className: styles_css_default["dismiss-control"], ariaLabel: i18n("dismissAriaLabel", dismissAriaLabel), onClick: () => onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss(), ref: dismissButtonRef })
  );
  const isDialog = showDismissButton;
  const shouldTrapFocus = showDismissButton && variant !== "annotation";
  const dialogProps = isDialog ? {
    role: "dialog",
    "aria-labelledby": ariaLabelledby !== null && ariaLabelledby !== void 0 ? ariaLabelledby : header ? labelledById : void 0
  } : {};
  return import_react4.default.createElement(
    "div",
    Object.assign({ className: clsx_m_default(styles_css_default.body, className, {
      [styles_css_default["body-overflow-visible"]]: overflowVisible === "both"
    }), onKeyDown }, dialogProps),
    import_react4.default.createElement(
      focus_lock_default,
      { disabled: !shouldTrapFocus, autoFocus: false },
      header && import_react4.default.createElement(
        "div",
        { className: clsx_m_default(styles_css_default["header-row"], showDismissButton && styles_css_default["has-dismiss"]) },
        dismissButton,
        import_react4.default.createElement(
          "div",
          { className: styles_css_default.header, id: labelledById },
          import_react4.default.createElement("h2", null, header)
        )
      ),
      import_react4.default.createElement(
        "div",
        { className: !header && showDismissButton ? styles_css_default["has-dismiss"] : void 0 },
        !header && dismissButton,
        import_react4.default.createElement("div", { className: clsx_m_default(styles_css_default.content, { [styles_css_default["content-overflow-visible"]]: !!overflowVisible }) }, children)
      )
    )
  );
}

// ../node_modules/@cloudscape-design/components/popover/container.js
var import_react6 = __toESM(require_react());

// ../node_modules/@cloudscape-design/components/popover/use-popover-position.js
var import_react5 = __toESM(require_react());

// ../node_modules/@cloudscape-design/components/popover/utils/positions.js
var ARROW_OFFSET = 12;
var PRIORITY_MAPPING = {
  top: [
    "top-center",
    "top-right",
    "top-left",
    "bottom-center",
    "bottom-right",
    "bottom-left",
    "right-top",
    "right-bottom",
    "left-top",
    "left-bottom"
  ],
  bottom: [
    "bottom-center",
    "bottom-right",
    "bottom-left",
    "top-center",
    "top-right",
    "top-left",
    "right-top",
    "right-bottom",
    "left-top",
    "left-bottom"
  ],
  left: [
    "left-top",
    "left-bottom",
    "right-top",
    "right-bottom",
    "bottom-center",
    "top-center",
    "bottom-left",
    "top-left",
    "bottom-right",
    "top-right"
  ],
  right: [
    "right-top",
    "right-bottom",
    "left-top",
    "left-bottom",
    "bottom-center",
    "top-center",
    "bottom-right",
    "top-right",
    "bottom-left",
    "top-left"
  ]
};
var RECTANGLE_CALCULATIONS = {
  "top-center": ({ body, trigger, arrow }) => {
    return {
      insetBlockStart: trigger.insetBlockStart - body.blockSize - arrow.blockSize,
      insetInlineStart: trigger.insetInlineStart + trigger.inlineSize / 2 - body.inlineSize / 2,
      inlineSize: body.inlineSize,
      blockSize: body.blockSize
    };
  },
  "top-right": ({ body, trigger, arrow }) => {
    return {
      insetBlockStart: trigger.insetBlockStart - body.blockSize - arrow.blockSize,
      insetInlineStart: trigger.insetInlineStart + trigger.inlineSize / 2 - ARROW_OFFSET - arrow.inlineSize / 2,
      inlineSize: body.inlineSize,
      blockSize: body.blockSize
    };
  },
  "top-left": ({ body, trigger, arrow }) => {
    return {
      insetBlockStart: trigger.insetBlockStart - body.blockSize - arrow.blockSize,
      insetInlineStart: trigger.insetInlineStart + trigger.inlineSize / 2 + ARROW_OFFSET + arrow.inlineSize / 2 - body.inlineSize,
      inlineSize: body.inlineSize,
      blockSize: body.blockSize
    };
  },
  "bottom-center": ({ body, trigger, arrow }) => {
    return {
      insetBlockStart: trigger.insetBlockStart + trigger.blockSize + arrow.blockSize,
      insetInlineStart: trigger.insetInlineStart + trigger.inlineSize / 2 - body.inlineSize / 2,
      inlineSize: body.inlineSize,
      blockSize: body.blockSize
    };
  },
  "bottom-right": ({ body, trigger, arrow }) => {
    return {
      insetBlockStart: trigger.insetBlockStart + trigger.blockSize + arrow.blockSize,
      insetInlineStart: trigger.insetInlineStart + trigger.inlineSize / 2 - ARROW_OFFSET - arrow.inlineSize / 2,
      inlineSize: body.inlineSize,
      blockSize: body.blockSize
    };
  },
  "bottom-left": ({ body, trigger, arrow }) => {
    return {
      insetBlockStart: trigger.insetBlockStart + trigger.blockSize + arrow.blockSize,
      insetInlineStart: trigger.insetInlineStart + trigger.inlineSize / 2 + ARROW_OFFSET + arrow.inlineSize / 2 - body.inlineSize,
      inlineSize: body.inlineSize,
      blockSize: body.blockSize
    };
  },
  "right-top": ({ body, trigger, arrow }) => {
    return {
      insetBlockStart: trigger.insetBlockStart + trigger.blockSize / 2 - ARROW_OFFSET - arrow.blockSize,
      insetInlineStart: trigger.insetInlineStart + trigger.inlineSize + arrow.blockSize,
      inlineSize: body.inlineSize,
      blockSize: body.blockSize
    };
  },
  "right-bottom": ({ body, trigger, arrow }) => {
    return {
      insetBlockStart: trigger.insetBlockStart + trigger.blockSize / 2 - body.blockSize + ARROW_OFFSET + arrow.blockSize,
      insetInlineStart: trigger.insetInlineStart + trigger.inlineSize + arrow.blockSize,
      inlineSize: body.inlineSize,
      blockSize: body.blockSize
    };
  },
  "left-top": ({ body, trigger, arrow }) => {
    return {
      insetBlockStart: trigger.insetBlockStart + trigger.blockSize / 2 - ARROW_OFFSET - arrow.blockSize,
      insetInlineStart: trigger.insetInlineStart - body.inlineSize - arrow.blockSize,
      inlineSize: body.inlineSize,
      blockSize: body.blockSize
    };
  },
  "left-bottom": ({ body, trigger, arrow }) => {
    return {
      insetBlockStart: trigger.insetBlockStart + trigger.blockSize / 2 - body.blockSize + ARROW_OFFSET + arrow.blockSize,
      insetInlineStart: trigger.insetInlineStart - body.inlineSize - arrow.blockSize,
      inlineSize: body.inlineSize,
      blockSize: body.blockSize
    };
  }
};
function fitIntoContainer(inner, outer) {
  let { insetInlineStart, inlineSize, insetBlockStart, blockSize } = inner;
  if (insetInlineStart < outer.insetInlineStart) {
    inlineSize = insetInlineStart + inlineSize - outer.insetInlineStart;
    insetInlineStart = outer.insetInlineStart;
  } else if (insetInlineStart + inlineSize > outer.insetInlineStart + outer.inlineSize) {
    inlineSize = outer.insetInlineStart + outer.inlineSize - insetInlineStart;
  }
  if (insetBlockStart < outer.insetBlockStart) {
    blockSize = insetBlockStart + blockSize - outer.insetBlockStart;
    insetBlockStart = outer.insetBlockStart;
  } else if (insetBlockStart + blockSize > outer.insetBlockStart + outer.blockSize) {
    blockSize = outer.insetBlockStart + outer.blockSize - insetBlockStart;
  }
  return { insetInlineStart, inlineSize, insetBlockStart, blockSize };
}
function getTallestRect(rect1, rect2) {
  return rect1.blockSize >= rect2.blockSize ? rect1 : rect2;
}
function getIntersection(rectangles) {
  let boundingBox = null;
  for (const currentRect of rectangles) {
    if (!boundingBox) {
      boundingBox = currentRect;
      continue;
    }
    const insetInlineStart = Math.max(boundingBox.insetInlineStart, currentRect.insetInlineStart);
    const insetBlockStart = Math.max(boundingBox.insetBlockStart, currentRect.insetBlockStart);
    const insetInlineEnd = Math.min(boundingBox.insetInlineStart + boundingBox.inlineSize, currentRect.insetInlineStart + currentRect.inlineSize);
    const insetBlockEnd = Math.min(boundingBox.insetBlockStart + boundingBox.blockSize, currentRect.insetBlockStart + currentRect.blockSize);
    if (insetInlineEnd < insetInlineStart || insetBlockEnd < insetBlockStart) {
      return null;
    }
    boundingBox = {
      insetInlineStart,
      insetBlockStart,
      inlineSize: insetInlineEnd - insetInlineStart,
      blockSize: insetBlockEnd - insetBlockStart
    };
  }
  return boundingBox;
}
function calculatePosition({
  preferredPosition,
  fixedInternalPosition,
  trigger,
  arrow,
  body,
  container,
  viewport,
  // the popover is only bound by the viewport if it is rendered in a portal
  renderWithPortal,
  allowVerticalOverflow
}) {
  let bestOption = null;
  const preferredInternalPositions = fixedInternalPosition ? [fixedInternalPosition] : PRIORITY_MAPPING[preferredPosition];
  for (const internalPosition2 of preferredInternalPositions) {
    const rect2 = RECTANGLE_CALCULATIONS[internalPosition2]({ body, trigger, arrow });
    const visibleArea = renderWithPortal ? getIntersection([rect2, viewport]) : getIntersection([rect2, viewport, container]);
    const fitsWithoutOverflow = visibleArea && visibleArea.inlineSize === body.inlineSize && visibleArea.blockSize === body.blockSize;
    if (fitsWithoutOverflow) {
      return { internalPosition: internalPosition2, rect: rect2 };
    }
    const newOption = { rect: rect2, internalPosition: internalPosition2, visibleArea };
    bestOption = getBestOption(newOption, bestOption);
  }
  const internalPosition = (bestOption === null || bestOption === void 0 ? void 0 : bestOption.internalPosition) || "right-top";
  const rect = RECTANGLE_CALCULATIONS[internalPosition]({ body, trigger, arrow });
  const tallestBoundingContainer = getTallestRect(viewport, container);
  const boundingContainer = allowVerticalOverflow && isTopOrBottom(internalPosition) ? {
    insetBlockStart: tallestBoundingContainer.insetBlockStart,
    blockSize: tallestBoundingContainer.blockSize,
    insetInlineStart: viewport.insetInlineStart,
    inlineSize: viewport.inlineSize
  } : viewport;
  const optimizedRect = fitIntoContainer(rect, boundingContainer);
  const scrollable = optimizedRect.blockSize < rect.blockSize;
  return { internalPosition, rect: optimizedRect, scrollable };
}
function getBestOption(option1, option2) {
  if (!(option2 === null || option2 === void 0 ? void 0 : option2.visibleArea)) {
    return option1;
  }
  if (!option1.visibleArea) {
    return option2;
  }
  if (option1.visibleArea.inlineSize === option2.visibleArea.inlineSize) {
    return option1.visibleArea.blockSize > option2.visibleArea.blockSize ? option1 : option2;
  }
  return option1.visibleArea.inlineSize > option2.visibleArea.inlineSize ? option1 : option2;
}
function getOffsetDimensions(element) {
  return { offsetHeight: element.offsetHeight, offsetWidth: element.offsetWidth };
}
function getDimensions(element) {
  const computedStyle = getComputedStyle(element);
  return {
    inlineSize: parseFloat(computedStyle.inlineSize),
    blockSize: parseFloat(computedStyle.blockSize)
  };
}
function isTopOrBottom(internalPosition) {
  return ["top", "bottom"].includes(internalPosition.split("-")[0]);
}
function isCenterOutside(child, parent) {
  const childCenter = child.insetBlockStart + child.blockSize / 2;
  const overflowsBlockStart = childCenter < parent.insetBlockStart;
  const overflowsBlockEnd = childCenter > parent.insetBlockEnd;
  return overflowsBlockStart || overflowsBlockEnd;
}

// ../node_modules/@cloudscape-design/components/popover/use-popover-position.js
function usePopoverPosition({ popoverRef, bodyRef, arrowRef, trackRef, contentRef, allowScrollToFit, allowVerticalOverflow, preferredPosition, renderWithPortal, keepPosition, hideOnOverscroll }) {
  const previousInternalPositionRef = (0, import_react5.useRef)(null);
  const [popoverStyle, setPopoverStyle] = (0, import_react5.useState)({});
  const [internalPosition, setInternalPosition] = (0, import_react5.useState)(null);
  const [isOverscrolling, setIsOverscrolling] = (0, import_react5.useState)(false);
  const positionHandlerRef = (0, import_react5.useRef)(() => {
  });
  const scrollableContainerRectRef = (0, import_react5.useRef)(null);
  const updatePositionHandler = (0, import_react5.useCallback)((onContentResize = false) => {
    var _a;
    if (!trackRef.current || !popoverRef.current || !bodyRef.current || !contentRef.current || !arrowRef.current) {
      return;
    }
    const popover = popoverRef.current;
    const body = bodyRef.current;
    const arrow = arrowRef.current;
    const document2 = popover.ownerDocument;
    const track = trackRef.current;
    const { offsetWidth, offsetHeight } = getOffsetDimensions(popover);
    if (offsetWidth === 0 || offsetHeight === 0 || !nodeContains(document2.body, track)) {
      return;
    }
    const prevInsetBlockStart = popover.style.insetBlockStart;
    const prevInsetInlineStart = popover.style.insetInlineStart;
    popover.style.insetBlockStart = "0";
    popover.style.insetInlineStart = "0";
    body.style.maxBlockSize = "";
    body.style.overflowX = "";
    body.style.overflowY = "";
    const viewportRect = getViewportRect(document2.defaultView);
    const trackRect = getLogicalBoundingClientRect(track);
    const arrowRect = getDimensions(arrow);
    const { containingBlock, boundary } = findUpUntilMultiple({
      startElement: popover,
      tests: {
        containingBlock: isContainingBlock,
        boundary: (element) => isContainingBlock(element) || isBoundary(element)
      }
    });
    const containingBlockRect = containingBlock ? getLogicalBoundingClientRect(containingBlock) : viewportRect;
    const boundaryRect = boundary ? getLogicalBoundingClientRect(boundary) : getDocumentRect(document2);
    const bodyBorderWidth = getBorderWidth(body);
    const contentRect = getLogicalBoundingClientRect(contentRef.current);
    const contentBoundingBox = {
      inlineSize: contentRect.inlineSize + 2 * bodyBorderWidth,
      blockSize: contentRect.blockSize + 2 * bodyBorderWidth
    };
    const shouldKeepPosition = keepPosition && onContentResize && !!previousInternalPositionRef.current;
    const fixedInternalPosition = (_a = shouldKeepPosition && previousInternalPositionRef.current) !== null && _a !== void 0 ? _a : void 0;
    const { scrollable, internalPosition: newInternalPosition, rect } = calculatePosition({
      preferredPosition,
      fixedInternalPosition,
      trigger: trackRect,
      arrow: arrowRect,
      body: contentBoundingBox,
      container: boundaryRect,
      viewport: viewportRect,
      renderWithPortal,
      allowVerticalOverflow
    });
    const popoverOffset = toRelativePosition(rect, containingBlockRect);
    const trackRelativeOffset = toRelativePosition(popoverOffset, toRelativePosition(trackRect, containingBlockRect));
    popover.style.insetBlockStart = prevInsetBlockStart;
    popover.style.insetInlineStart = prevInsetInlineStart;
    if (scrollable) {
      body.style.maxBlockSize = rect.blockSize + "px";
      body.style.overflowX = "hidden";
      body.style.overflowY = "auto";
    }
    previousInternalPositionRef.current = newInternalPosition;
    setInternalPosition(newInternalPosition);
    const shouldScroll = allowScrollToFit && !shouldKeepPosition;
    const insetBlockStart = shouldScroll ? popoverOffset.insetBlockStart + calculateScroll(rect) : popoverOffset.insetBlockStart;
    setPopoverStyle({ insetBlockStart, insetInlineStart: popoverOffset.insetInlineStart });
    if (shouldScroll) {
      const scrollableParent = getFirstScrollableParent(popover);
      scrollRectangleIntoView(rect, scrollableParent);
    }
    if (hideOnOverscroll && trackRef.current instanceof HTMLElement) {
      const scrollableContainer = getFirstScrollableParent(trackRef.current);
      if (scrollableContainer) {
        scrollableContainerRectRef.current = getLogicalBoundingClientRect(scrollableContainer);
      }
    }
    positionHandlerRef.current = () => {
      const trackRect2 = getLogicalBoundingClientRect(track);
      const newTrackOffset = toRelativePosition(trackRect2, containingBlock ? getLogicalBoundingClientRect(containingBlock) : viewportRect);
      setPopoverStyle({
        insetBlockStart: newTrackOffset.insetBlockStart + trackRelativeOffset.insetBlockStart,
        insetInlineStart: newTrackOffset.insetInlineStart + trackRelativeOffset.insetInlineStart
      });
      if (hideOnOverscroll && scrollableContainerRectRef.current) {
        setIsOverscrolling(isCenterOutside(trackRect2, scrollableContainerRectRef.current));
      }
    };
  }, [
    trackRef,
    popoverRef,
    bodyRef,
    contentRef,
    arrowRef,
    keepPosition,
    preferredPosition,
    renderWithPortal,
    allowVerticalOverflow,
    allowScrollToFit,
    hideOnOverscroll
  ]);
  return { updatePositionHandler, popoverStyle, internalPosition, positionHandlerRef, isOverscrolling };
}
function getBorderWidth(element) {
  return parseInt(getComputedStyle(element).borderWidth) || 0;
}
function toRelativePosition(element, parent) {
  return {
    insetBlockStart: element.insetBlockStart - parent.insetBlockStart,
    insetInlineStart: element.insetInlineStart - parent.insetInlineStart
  };
}
function getViewportRect(window2) {
  var _a, _b, _c, _d;
  return {
    insetBlockStart: 0,
    insetInlineStart: 0,
    inlineSize: (_b = (_a = window2.visualViewport) === null || _a === void 0 ? void 0 : _a.width) !== null && _b !== void 0 ? _b : window2.innerWidth,
    blockSize: (_d = (_c = window2.visualViewport) === null || _c === void 0 ? void 0 : _c.height) !== null && _d !== void 0 ? _d : window2.innerHeight
  };
}
function getDocumentRect(document2) {
  const { insetBlockStart, insetInlineStart } = getLogicalBoundingClientRect(document2.documentElement);
  return {
    insetBlockStart,
    insetInlineStart,
    inlineSize: document2.documentElement.scrollWidth,
    blockSize: document2.documentElement.scrollHeight
  };
}
function isBoundary(element) {
  const computedStyle = getComputedStyle(element);
  return !!computedStyle.clipPath && computedStyle.clipPath !== "none";
}

// ../node_modules/@cloudscape-design/components/popover/container.js
function PopoverContainer({ position, trackRef, trackKey, arrow, children, zIndex, renderWithPortal, size, fixedWidth, variant, keepPosition, allowScrollToFit, allowVerticalOverflow, hideOnOverscroll, className }) {
  const bodyRef = (0, import_react6.useRef)(null);
  const contentRef = (0, import_react6.useRef)(null);
  const popoverRef = (0, import_react6.useRef)(null);
  const arrowRef = (0, import_react6.useRef)(null);
  const isRefresh = useVisualRefresh();
  const { updatePositionHandler, popoverStyle, internalPosition, positionHandlerRef, isOverscrolling } = usePopoverPosition({
    popoverRef,
    bodyRef,
    arrowRef,
    trackRef,
    contentRef,
    allowScrollToFit,
    allowVerticalOverflow,
    preferredPosition: position,
    renderWithPortal,
    keepPosition,
    hideOnOverscroll
  });
  (0, import_react6.useLayoutEffect)(() => {
    updatePositionHandler();
  }, [updatePositionHandler, trackKey]);
  useResizeObserver(contentRef, () => {
    updatePositionHandler(true);
  });
  (0, import_react6.useLayoutEffect)(() => {
    const onClick = (event) => {
      if (
        // Do not update position if keepPosition is true.
        keepPosition || // If the click was on the trigger, this will make the popover appear or disappear,
        // so no need to update its position either in this case.
        nodeContains(trackRef.current, event.target)
      ) {
        return;
      }
      requestAnimationFrame(() => {
        updatePositionHandler();
      });
    };
    const updatePositionOnResize = () => requestAnimationFrame(() => updatePositionHandler());
    const refreshPosition = () => requestAnimationFrame(() => positionHandlerRef.current());
    const controller = new AbortController();
    window.addEventListener("click", onClick, { signal: controller.signal });
    window.addEventListener("resize", updatePositionOnResize, { signal: controller.signal });
    window.addEventListener("scroll", refreshPosition, { capture: true, signal: controller.signal });
    return () => {
      controller.abort();
    };
  }, [hideOnOverscroll, keepPosition, positionHandlerRef, trackRef, updatePositionHandler]);
  return isOverscrolling ? null : import_react6.default.createElement(
    "div",
    { ref: popoverRef, style: Object.assign(Object.assign({}, popoverStyle), { zIndex }), className: clsx_m_default(styles_css_default.container, isRefresh && styles_css_default.refresh, className) },
    import_react6.default.createElement("div", { ref: arrowRef, className: clsx_m_default(styles_css_default[`container-arrow`], styles_css_default[`container-arrow-position-${internalPosition}`]), "aria-hidden": true }, arrow(internalPosition)),
    import_react6.default.createElement(
      "div",
      { ref: bodyRef, className: clsx_m_default(styles_css_default["container-body"], styles_css_default[`container-body-size-${size}`], {
        [styles_css_default["fixed-width"]]: fixedWidth,
        [styles_css_default[`container-body-variant-${variant}`]]: variant
      }) },
      import_react6.default.createElement("div", { ref: contentRef }, children)
    )
  );
}

// ../node_modules/@cloudscape-design/components/internal/components/portal/index.js
var import_react7 = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());
function manageDefaultContainer(setState) {
  const newContainer = document.createElement("div");
  document.body.appendChild(newContainer);
  setState(newContainer);
  return () => {
    document.body.removeChild(newContainer);
  };
}
function manageAsyncContainer(getContainer, removeContainer, setState) {
  let newContainer;
  getContainer().then((container) => {
    newContainer = container;
    setState(container);
  }, (error) => {
    console.warn("[AwsUi] [portal]: failed to load portal root", error);
  });
  return () => {
    removeContainer(newContainer);
  };
}
function Portal({ container, getContainer, removeContainer, children }) {
  const [activeContainer, setActiveContainer] = (0, import_react7.useState)(container !== null && container !== void 0 ? container : null);
  (0, import_react7.useLayoutEffect)(() => {
    if (container) {
      setActiveContainer(container);
      return;
    }
    if (isDevelopment) {
      if (getContainer && !removeContainer) {
        warnOnce("portal", "`removeContainer` is required when `getContainer` is provided");
      }
      if (!getContainer && removeContainer) {
        warnOnce("portal", "`getContainer` is required when `removeContainer` is provided");
      }
    }
    if (getContainer && removeContainer) {
      return manageAsyncContainer(getContainer, removeContainer, setActiveContainer);
    }
    return manageDefaultContainer(setActiveContainer);
  }, [container, getContainer, removeContainer]);
  return activeContainer && (0, import_react_dom.createPortal)(children, activeContainer);
}

// ../node_modules/@cloudscape-design/components/internal/components/transition/index.js
var import_react8 = __toESM(require_react());
var import_react9 = __toESM(require_react());
function Transition(_a) {
  var { in: isIn, children, exit = true, onStatusChange = () => void 0, disabled = false, transitionChangeDelay } = _a, rest = __rest(_a, ["in", "children", "exit", "onStatusChange", "disabled", "transitionChangeDelay"]);
  const transitionRootElement = (0, import_react9.useRef)(null);
  const [transitionState, setTransitionState] = (0, import_react8.useState)(isIn ? "entered" : "exited");
  const motionDisabled = useReducedMotion(transitionRootElement) || disabled;
  const addTransitionEndListener = (0, import_react9.useCallback)((done) => {
    const node = transitionRootElement.current;
    if (node === null) {
      return;
    }
    const controller = new AbortController();
    const listener = (e) => {
      if (e.target === node) {
        controller.abort();
        done();
      }
    };
    node.addEventListener("transitionend", listener, { signal: controller.signal });
    node.addEventListener("animationend", listener, { signal: controller.signal });
  }, []);
  return import_react8.default.createElement(Transition_default, Object.assign({ addEndListener: addTransitionEndListener, timeout: motionDisabled ? 0 : void 0, in: isIn, nodeRef: transitionRootElement, exit, onEnter: (isAppearing) => {
    if (!isAppearing) {
      setTransitionState("enter");
      onStatusChange("enter");
    }
  }, onEntering: (isAppearing) => {
    var _a2;
    if (!isAppearing) {
      void ((_a2 = transitionRootElement.current) === null || _a2 === void 0 ? void 0 : _a2.offsetHeight);
      if (transitionChangeDelay === null || transitionChangeDelay === void 0 ? void 0 : transitionChangeDelay.entering) {
        setTimeout(() => {
          setTransitionState("entering");
          onStatusChange("entering");
        }, transitionChangeDelay === null || transitionChangeDelay === void 0 ? void 0 : transitionChangeDelay.entering);
      } else {
        setTransitionState("entering");
        onStatusChange("entering");
      }
    }
  }, onEntered: (isAppearing) => {
    if (!isAppearing) {
      setTransitionState("entered");
      onStatusChange("entered");
    }
  }, onExit: () => {
    setTransitionState("exit");
    onStatusChange("exit");
  }, onExiting: () => {
    setTransitionState("exiting");
    onStatusChange("exiting");
  }, onExited: () => {
    setTransitionState("exited");
    onStatusChange("exited");
  } }, rest), () => children(transitionState, transitionRootElement));
}

// ../node_modules/@cloudscape-design/components/internal/components/tooltip/styles.css.js
import "/Users/cmgabri/Desktop/osdu-decoupled/frontend-uxpin/node_modules/@cloudscape-design/components/internal/components/tooltip/styles.scoped.css";
var styles_css_default3 = {
  "root": "awsui_root_1qprf_160mh_5"
};

// ../node_modules/@cloudscape-design/components/internal/components/tooltip/index.js
function Tooltip({ value, trackRef, trackKey, className, contentAttributes = {}, position = "top", size = "small", hideOnOverscroll, onDismiss }) {
  if (!trackKey && (typeof value === "string" || typeof value === "number")) {
    trackKey = value;
  }
  (0, import_react10.useEffect)(() => {
    const controller = new AbortController();
    window.addEventListener("keydown", (event) => {
      if (event.key === "Escape") {
        event.stopPropagation();
        onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss();
      }
    }, {
      // The tooltip is often activated on mouseover, which means the focus can
      // be anywhere else on the page. Capture also means that this gets called
      // before any wrapper modals or dialogs can detect it and act on it.
      capture: true,
      signal: controller.signal
    });
    return () => {
      controller.abort();
    };
  }, [onDismiss]);
  return import_react10.default.createElement(
    Portal,
    null,
    import_react10.default.createElement(
      "div",
      Object.assign({ className: styles_css_default3.root }, contentAttributes, { "data-testid": trackKey }),
      import_react10.default.createElement(Transition, { in: true }, () => import_react10.default.createElement(
        PopoverContainer,
        { trackRef, trackKey, size, fixedWidth: false, position, zIndex: 7e3, arrow: (position2) => import_react10.default.createElement(arrow_default, { position: position2 }), hideOnOverscroll, className },
        import_react10.default.createElement(PopoverBody, { dismissButton: false, dismissAriaLabel: void 0, onDismiss: void 0, header: void 0 }, value)
      ))
    )
  );
}

// ../node_modules/@cloudscape-design/components/internal/context/button-context.js
var import_react11 = __toESM(require_react());
var ButtonContext = (0, import_react11.createContext)({
  onClick: () => {
  }
});
function useButtonContext() {
  return (0, import_react11.useContext)(ButtonContext);
}

// ../node_modules/@cloudscape-design/components/internal/context/single-tab-stop-navigation-context.js
var import_react12 = __toESM(require_react());
var defaultValue = {
  navigationActive: false,
  registerFocusable: () => () => {
  }
};
var SingleTabStopNavigationContext = (0, import_react12.createContext)(defaultValue);
function useSingleTabStopNavigation(focusable, options) {
  var _a;
  const { navigationActive: contextNavigationActive, registerFocusable } = (0, import_react12.useContext)(SingleTabStopNavigationContext);
  const [focusTargetActive, setFocusTargetActive] = (0, import_react12.useState)(false);
  const navigationDisabled = (options === null || options === void 0 ? void 0 : options.tabIndex) && (options === null || options === void 0 ? void 0 : options.tabIndex) < 0;
  const navigationActive = contextNavigationActive && !navigationDisabled;
  (0, import_react12.useLayoutEffect)(() => {
    if (navigationActive && focusable && focusable.current) {
      const unregister = registerFocusable(focusable.current, (isFocusable) => setFocusTargetActive(isFocusable));
      return () => unregister();
    }
  });
  let tabIndex = options === null || options === void 0 ? void 0 : options.tabIndex;
  if (navigationActive) {
    tabIndex = !focusTargetActive ? -1 : (_a = options === null || options === void 0 ? void 0 : options.tabIndex) !== null && _a !== void 0 ? _a : 0;
  }
  return { navigationActive, tabIndex };
}
var SingleTabStopNavigationProvider = (0, import_react12.forwardRef)(({ navigationActive, children, getNextFocusTarget, isElementSuppressed, onRegisterFocusable, onUnregisterActive }, ref) => {
  const focusables = (0, import_react12.useRef)(/* @__PURE__ */ new Set());
  const focusHandlers = (0, import_react12.useRef)(/* @__PURE__ */ new Map());
  const focusablesState = (0, import_react12.useRef)(/* @__PURE__ */ new WeakMap());
  const focusTarget = (0, import_react12.useRef)(null);
  function onUnregisterFocusable(focusableElement) {
    const isUnregisteringFocusedNode = nodeBelongs(focusableElement, document.activeElement);
    if (isUnregisteringFocusedNode) {
      setTimeout(() => onUnregisterActive === null || onUnregisterActive === void 0 ? void 0 : onUnregisterActive(focusableElement), 0);
    }
  }
  function registerFocusable(focusableElement, changeHandler) {
    focusables.current.add(focusableElement);
    focusHandlers.current.set(focusableElement, changeHandler);
    const isFocusable = !!focusablesState.current.get(focusableElement);
    const newIsFocusable = focusTarget.current === focusableElement || !!(isElementSuppressed === null || isElementSuppressed === void 0 ? void 0 : isElementSuppressed(focusableElement));
    if (newIsFocusable !== isFocusable) {
      focusablesState.current.set(focusableElement, newIsFocusable);
      changeHandler(newIsFocusable);
    }
    onRegisterFocusable === null || onRegisterFocusable === void 0 ? void 0 : onRegisterFocusable(focusableElement);
    return () => unregisterFocusable(focusableElement);
  }
  function unregisterFocusable(focusableElement) {
    focusables.current.delete(focusableElement);
    focusHandlers.current.delete(focusableElement);
    onUnregisterFocusable === null || onUnregisterFocusable === void 0 ? void 0 : onUnregisterFocusable(focusableElement);
  }
  function updateFocusTarget() {
    var _a;
    focusTarget.current = getNextFocusTarget();
    for (const focusableElement of focusables.current) {
      const isFocusable = (_a = focusablesState.current.get(focusableElement)) !== null && _a !== void 0 ? _a : false;
      const newIsFocusable = focusTarget.current === focusableElement || !!(isElementSuppressed === null || isElementSuppressed === void 0 ? void 0 : isElementSuppressed(focusableElement));
      if (newIsFocusable !== isFocusable) {
        focusablesState.current.set(focusableElement, newIsFocusable);
        focusHandlers.current.get(focusableElement)(newIsFocusable);
      }
    }
  }
  function getFocusTarget() {
    return focusTarget.current;
  }
  function isRegistered(element) {
    return focusables.current.has(element);
  }
  (0, import_react12.useImperativeHandle)(ref, () => ({ updateFocusTarget, getFocusTarget, isRegistered }));
  return import_react12.default.createElement(SingleTabStopNavigationContext.Provider, { value: { navigationActive, registerFocusable } }, children);
});

// ../node_modules/@cloudscape-design/components/internal/hooks/use-hidden-description/index.js
var import_react13 = __toESM(require_react());
function useHiddenDescription(description) {
  const id = useUniqueId();
  return {
    targetProps: {
      "aria-describedby": description ? id : void 0
    },
    descriptionEl: description ? import_react13.default.createElement("span", { id, hidden: true }, description) : null,
    descriptionId: id
  };
}

// ../node_modules/@cloudscape-design/components/internal/hooks/use-performance-marks/index.js
var import_react16 = __toESM(require_react());

// ../node_modules/@cloudscape-design/components/internal/hooks/use-dom-attribute/index.js
var import_react14 = __toESM(require_react());
function useDOMAttribute(elementRef, attributeName, value) {
  const attributeValueRef = (0, import_react14.useRef)();
  (0, import_react14.useEffect)(() => {
    var _a;
    attributeValueRef.current = value;
    (_a = elementRef.current) === null || _a === void 0 ? void 0 : _a.setAttribute(attributeName, value);
  }, [attributeName, value, elementRef]);
  return {
    [attributeName]: attributeValueRef.current
  };
}

// ../node_modules/@cloudscape-design/components/internal/hooks/use-effect-on-update.js
var import_react15 = __toESM(require_react());
function useEffectOnUpdate(callback, deps) {
  const isFirstRender = (0, import_react15.useRef)(true);
  (0, import_react15.useEffect)(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
    } else {
      return callback();
    }
  }, deps);
}

// ../node_modules/@cloudscape-design/components/internal/hooks/use-performance-marks/is-in-viewport.js
var map = /* @__PURE__ */ new WeakMap();
var MANUAL_TRIGGER_DELAY = 150;
function isInViewport(element, callback) {
  let resolve = (value) => {
    resolve = () => {
    };
    callback(value);
  };
  map.set(element, (inViewport) => resolve(inViewport));
  observer.observe(element);
  const timeoutHandle = setTimeout(() => resolve(false), MANUAL_TRIGGER_DELAY);
  return () => {
    clearTimeout(timeoutHandle);
    map.delete(element);
    observer.unobserve(element);
  };
}
function createIntersectionObserver(callback) {
  if (typeof IntersectionObserver === "undefined") {
    return {
      observe: () => {
      },
      unobserve: () => {
      }
    };
  }
  return new IntersectionObserver(callback);
}
var observer = createIntersectionObserver(function isInViewportObserver(entries) {
  var _a;
  for (const entry of entries) {
    observer.unobserve(entry.target);
    (_a = map.get(entry.target)) === null || _a === void 0 ? void 0 : _a(entry.isIntersecting);
    map.delete(entry.target);
  }
});

// ../node_modules/@cloudscape-design/components/internal/hooks/use-performance-marks/index.js
var EVALUATE_COMPONENT_VISIBILITY_EVENT = "awsui-evaluate-component-visibility";
var useEvaluateComponentVisibility = () => {
  const [evaluateComponentVisibility, setEvaluateComponentVisibility] = (0, import_react16.useState)(false);
  (0, import_react16.useEffect)(() => {
    const handleEvaluateComponentVisibility = () => {
      setEvaluateComponentVisibility((prev) => !prev);
    };
    document.addEventListener(EVALUATE_COMPONENT_VISIBILITY_EVENT, handleEvaluateComponentVisibility);
    return () => {
      document.removeEventListener(EVALUATE_COMPONENT_VISIBILITY_EVENT, handleEvaluateComponentVisibility);
    };
  }, []);
  return evaluateComponentVisibility;
};
function usePerformanceMarks(name, enabled, elementRef, getDetails, dependencies) {
  const id = useRandomId();
  const { isInModal } = useModalContext();
  const attributes = useDOMAttribute(elementRef, "data-analytics-performance-mark", id);
  const evaluateComponentVisibility = useEvaluateComponentVisibility();
  (0, import_react16.useEffect)(() => {
    if (!enabled() || !elementRef.current || isInModal) {
      return;
    }
    const elementVisible = elementRef.current.offsetWidth > 0 && elementRef.current.offsetHeight > 0 && getComputedStyle(elementRef.current).visibility !== "hidden";
    if (!elementVisible) {
      return;
    }
    const timestamp = performance.now();
    const cleanup = isInViewport(elementRef.current, (inViewport) => {
      performance.mark(`${name}Rendered`, {
        startTime: timestamp,
        detail: Object.assign({ source: "awsui", instanceIdentifier: id, inViewport }, getDetails())
      });
    });
    return cleanup;
  }, []);
  useEffectOnUpdate(() => {
    if (!enabled() || !elementRef.current || isInModal) {
      return;
    }
    const elementVisible = elementRef.current.offsetWidth > 0 && elementRef.current.offsetHeight > 0 && getComputedStyle(elementRef.current).visibility !== "hidden";
    if (!elementVisible) {
      return;
    }
    const timestamp = performance.now();
    const cleanup = isInViewport(elementRef.current, (inViewport) => {
      performance.mark(`${name}Updated`, {
        startTime: timestamp,
        detail: Object.assign({ source: "awsui", instanceIdentifier: id, inViewport }, getDetails())
      });
    });
    return cleanup;
  }, [evaluateComponentVisibility, ...dependencies]);
  return attributes;
}

// ../node_modules/@cloudscape-design/components/button/icon-helper.js
var React10 = __toESM(require_react());

// ../node_modules/@cloudscape-design/components/button/styles.css.js
import "/Users/cmgabri/Desktop/osdu-decoupled/frontend-uxpin/node_modules/@cloudscape-design/components/button/styles.scoped.css";
var styles_css_default4 = {
  "content": "awsui_content_vjswe_1w655_153",
  "button": "awsui_button_vjswe_1w655_157",
  "variant-normal": "awsui_variant-normal_vjswe_1w655_205",
  "disabled": "awsui_disabled_vjswe_1w655_223",
  "variant-primary": "awsui_variant-primary_vjswe_1w655_230",
  "variant-link": "awsui_variant-link_vjswe_1w655_255",
  "variant-icon": "awsui_variant-icon_vjswe_1w655_280",
  "variant-inline-icon": "awsui_variant-inline-icon_vjswe_1w655_305",
  "variant-inline-icon-pointer-target": "awsui_variant-inline-icon-pointer-target_vjswe_1w655_330",
  "variant-inline-link": "awsui_variant-inline-link_vjswe_1w655_355",
  "variant-modal-dismiss": "awsui_variant-modal-dismiss_vjswe_1w655_384",
  "variant-flashbar-icon": "awsui_variant-flashbar-icon_vjswe_1w655_409",
  "variant-breadcrumb-group": "awsui_variant-breadcrumb-group_vjswe_1w655_434",
  "variant-menu-trigger": "awsui_variant-menu-trigger_vjswe_1w655_464",
  "button-no-text": "awsui_button-no-text_vjswe_1w655_556",
  "button-no-wrap": "awsui_button-no-wrap_vjswe_1w655_560",
  "full-width": "awsui_full-width_vjswe_1w655_563",
  "icon-left": "awsui_icon-left_vjswe_1w655_585",
  "icon-right": "awsui_icon-right_vjswe_1w655_590",
  "icon": "awsui_icon_vjswe_1w655_585",
  "link": "awsui_link_vjswe_1w655_609",
  "disabled-with-reason": "awsui_disabled-with-reason_vjswe_1w655_609"
};

// ../node_modules/@cloudscape-design/components/button/icon-helper.js
function getIconAlign(props) {
  const standalone = props.variant === "icon" || props.variant === "inline-icon";
  return standalone ? "left" : props.iconAlign;
}
function IconWrapper(_a) {
  var { iconName, iconUrl, iconAlt, iconSvg, iconSize, badge } = _a, props = __rest(_a, ["iconName", "iconUrl", "iconAlt", "iconSvg", "iconSize", "badge"]);
  if (!iconName && !iconUrl && !iconSvg) {
    return null;
  }
  return React10.createElement(internal_default, { className: clsx_m_default(styles_css_default4.icon, styles_css_default4[`icon-${getIconAlign(props)}`], props.iconClass), name: iconName, url: iconUrl, svg: iconSvg, alt: iconAlt, size: iconSize, badge });
}
function LeftIcon(props) {
  if (props.loading) {
    return React10.createElement(InternalSpinner, { className: clsx_m_default(styles_css_default4.icon, styles_css_default4["icon-left"]) });
  } else if (getIconAlign(props) === "left") {
    return React10.createElement(IconWrapper, Object.assign({}, props));
  }
  return null;
}
function RightIcon(props) {
  if (getIconAlign(props) === "right") {
    return React10.createElement(IconWrapper, Object.assign({}, props));
  }
  return null;
}

// ../node_modules/@cloudscape-design/components/button/analytics-metadata/styles.css.js
import "/Users/cmgabri/Desktop/osdu-decoupled/frontend-uxpin/node_modules/@cloudscape-design/components/button/analytics-metadata/styles.scoped.css";
var styles_css_default5 = {
  "label": "awsui_label_1f1d4_ocied_5"
};

// ../node_modules/@cloudscape-design/components/button/test-classes/styles.css.js
import "/Users/cmgabri/Desktop/osdu-decoupled/frontend-uxpin/node_modules/@cloudscape-design/components/button/test-classes/styles.scoped.css";
var styles_css_default6 = {
  "disabled-reason-tooltip": "awsui_disabled-reason-tooltip_1ueyk_ca6yt_5",
  "external-icon": "awsui_external-icon_1ueyk_ca6yt_9"
};

// ../node_modules/@cloudscape-design/components/button/internal.js
var InternalButton = import_react17.default.forwardRef((_a, ref) => {
  var { children, iconName, __iconClass, onClick, onFollow, iconAlign = "left", iconUrl, iconSvg, iconAlt, variant = "normal", loading = false, loadingText, disabled = false, disabledReason, wrapText = true, href, external, target: targetOverride, rel, download, formAction = "submit", ariaLabel, ariaDescribedby, ariaExpanded, ariaControls, fullWidth, badge, i18nStrings, __nativeAttributes, __internalRootRef = null, __focusable = false, __injectAnalyticsComponentMetadata = false, __title, __emitPerformanceMarks = true, analyticsAction = "click" } = _a, props = __rest(_a, ["children", "iconName", "__iconClass", "onClick", "onFollow", "iconAlign", "iconUrl", "iconSvg", "iconAlt", "variant", "loading", "loadingText", "disabled", "disabledReason", "wrapText", "href", "external", "target", "rel", "download", "formAction", "ariaLabel", "ariaDescribedby", "ariaExpanded", "ariaControls", "fullWidth", "badge", "i18nStrings", "__nativeAttributes", "__internalRootRef", "__focusable", "__injectAnalyticsComponentMetadata", "__title", "__emitPerformanceMarks", "analyticsAction"]);
  const [showTooltip, setShowTooltip] = (0, import_react17.useState)(false);
  checkSafeUrl("Button", href);
  const isAnchor = Boolean(href);
  const target = targetOverride !== null && targetOverride !== void 0 ? targetOverride : external ? "_blank" : void 0;
  const isNotInteractive = loading || disabled;
  const isDisabledWithReason = (variant === "normal" || variant === "primary" || variant === "icon") && !!disabledReason && disabled;
  const hasAriaDisabled = loading && !disabled || disabled && __focusable || isDisabledWithReason;
  const shouldHaveContent = children && ["icon", "inline-icon", "flashbar-icon", "modal-dismiss", "inline-icon-pointer-target"].indexOf(variant) === -1;
  if ((iconName || iconUrl || iconSvg) && iconAlign === "right" && external) {
    warnOnce("Button", "A right-aligned icon should not be combined with an external icon.");
  }
  const buttonRef = (0, import_react17.useRef)(null);
  useForwardFocus(ref, buttonRef);
  const buttonContext = useButtonContext();
  const i18n = useInternalI18n("button");
  const uniqueId = useUniqueId("button");
  const { funnelInteractionId } = useFunnel();
  const { stepNumber, stepNameSelector } = useFunnelStep();
  const { subStepSelector, subStepNameSelector } = useFunnelSubStep();
  const performanceMarkAttributes = usePerformanceMarks("primaryButton", () => variant === "primary" && __emitPerformanceMarks && !loading && !disabled, buttonRef, () => {
    var _a2;
    return {
      loading,
      disabled,
      text: (_a2 = buttonRef.current) === null || _a2 === void 0 ? void 0 : _a2.innerText
    };
  }, [loading, disabled]);
  useModalContextLoadingButtonComponent(variant === "primary", loading);
  const { targetProps, descriptionEl } = useHiddenDescription(disabledReason);
  const handleClick = (event) => {
    if (isNotInteractive) {
      return event.preventDefault();
    }
    if (isAnchor && isPlainLeftClick(event)) {
      fireCancelableEvent(onFollow, { href, target }, event);
      if ((iconName === "external" || target === "_blank") && funnelInteractionId) {
        const stepName = getTextFromSelector(stepNameSelector);
        const subStepName = getTextFromSelector(subStepNameSelector);
        FunnelMetrics.externalLinkInteracted({
          funnelInteractionId,
          stepNumber,
          stepName,
          stepNameSelector,
          subStepSelector,
          subStepName,
          subStepNameSelector,
          elementSelector: getFunnelValueSelector(uniqueId),
          subStepAllSelector: getSubStepAllSelector()
        });
      }
    }
    const { altKey, button, ctrlKey, metaKey, shiftKey } = event;
    fireCancelableEvent(onClick, { altKey, button, ctrlKey, metaKey, shiftKey }, event);
    buttonContext.onClick({ variant });
  };
  const buttonClass = clsx_m_default(props.className, styles_css_default4.button, styles_css_default4[`variant-${variant}`], {
    [styles_css_default4.disabled]: isNotInteractive,
    [styles_css_default4["disabled-with-reason"]]: isDisabledWithReason,
    [styles_css_default4["button-no-wrap"]]: !wrapText,
    [styles_css_default4["button-no-text"]]: !shouldHaveContent,
    [styles_css_default4["full-width"]]: shouldHaveContent && fullWidth,
    [styles_css_default4.link]: isAnchor
  });
  const explicitTabIndex = __nativeAttributes && "tabIndex" in __nativeAttributes ? __nativeAttributes.tabIndex : void 0;
  const { tabIndex } = useSingleTabStopNavigation(buttonRef, {
    tabIndex: isAnchor && isNotInteractive && !isDisabledWithReason ? -1 : explicitTabIndex
  });
  const analyticsMetadata = disabled ? {} : {
    action: analyticsAction,
    detail: { label: { root: "self" } }
  };
  if (__injectAnalyticsComponentMetadata) {
    analyticsMetadata.component = {
      name: "awsui.Button",
      label: { root: "self" },
      properties: { variant, disabled: `${disabled}` }
    };
  }
  const buttonProps = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, props), __nativeAttributes), performanceMarkAttributes), {
    tabIndex,
    // https://github.com/microsoft/TypeScript/issues/36659
    ref: useMergeRefs(buttonRef, __internalRootRef),
    "aria-label": ariaLabel,
    "aria-describedby": ariaDescribedby,
    "aria-expanded": ariaExpanded,
    "aria-controls": ariaControls,
    // add ariaLabel as `title` as visible hint text
    title: __title !== null && __title !== void 0 ? __title : ariaLabel,
    className: buttonClass,
    onClick: handleClick,
    [DATA_ATTR_FUNNEL_VALUE]: uniqueId
  }), getAnalyticsMetadataAttribute(analyticsMetadata)), getAnalyticsLabelAttribute(children ? `.${styles_css_default5.label}` : ""));
  const iconProps = {
    loading,
    iconName,
    iconAlign,
    iconUrl,
    iconSvg,
    iconAlt,
    variant,
    badge,
    iconClass: __iconClass,
    iconSize: variant === "modal-dismiss" ? "medium" : "normal"
  };
  const buttonContent = import_react17.default.createElement(
    import_react17.default.Fragment,
    null,
    import_react17.default.createElement(LeftIcon, Object.assign({}, iconProps)),
    shouldHaveContent && import_react17.default.createElement(
      import_react17.default.Fragment,
      null,
      import_react17.default.createElement("span", { className: clsx_m_default(styles_css_default4.content, styles_css_default5.label) }, children),
      external && import_react17.default.createElement(
        import_react17.default.Fragment,
        null,
        " ",
        import_react17.default.createElement(internal_default, { name: "external", className: styles_css_default6["external-icon"], ariaLabel: i18n("i18nStrings.externalIconAriaLabel", i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.externalIconAriaLabel) })
      )
    ),
    import_react17.default.createElement(RightIcon, Object.assign({}, iconProps))
  );
  const { loadingButtonCount } = useFunnel();
  (0, import_react17.useEffect)(() => {
    if (loading) {
      loadingButtonCount.current++;
      return () => {
        loadingButtonCount.current--;
      };
    }
  }, [loading, loadingButtonCount]);
  const disabledReasonProps = Object.assign({ onFocus: isDisabledWithReason ? () => setShowTooltip(true) : void 0, onBlur: isDisabledWithReason ? () => setShowTooltip(false) : void 0, onMouseEnter: isDisabledWithReason ? () => setShowTooltip(true) : void 0, onMouseLeave: isDisabledWithReason ? () => setShowTooltip(false) : void 0 }, isDisabledWithReason ? targetProps : {});
  const disabledReasonContent = import_react17.default.createElement(
    import_react17.default.Fragment,
    null,
    descriptionEl,
    showTooltip && import_react17.default.createElement(Tooltip, { className: styles_css_default6["disabled-reason-tooltip"], trackRef: buttonRef, value: disabledReason, onDismiss: () => setShowTooltip(false) })
  );
  if (isAnchor) {
    return (
      // https://github.com/yannickcr/eslint-plugin-react/issues/2962
      // eslint-disable-next-line react/jsx-no-target-blank
      import_react17.default.createElement(
        import_react17.default.Fragment,
        null,
        import_react17.default.createElement(
          "a",
          Object.assign({}, buttonProps, {
            href,
            target,
            // security recommendation: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#target
            rel: rel !== null && rel !== void 0 ? rel : target === "_blank" ? "noopener noreferrer" : void 0,
            "aria-disabled": isNotInteractive ? true : void 0,
            download
          }, disabledReasonProps),
          buttonContent,
          isDisabledWithReason && disabledReasonContent
        ),
        loading && loadingText && import_react17.default.createElement(internal_default2, { tagName: "span", hidden: true }, loadingText)
      )
    );
  }
  return import_react17.default.createElement(
    import_react17.default.Fragment,
    null,
    import_react17.default.createElement(
      "button",
      Object.assign({}, buttonProps, { type: formAction === "none" ? "button" : "submit", disabled: disabled && !__focusable && !isDisabledWithReason, "aria-disabled": hasAriaDisabled ? true : void 0 }, disabledReasonProps),
      buttonContent,
      isDisabledWithReason && disabledReasonContent
    ),
    loading && loadingText && import_react17.default.createElement(internal_default2, { tagName: "span", hidden: true }, loadingText)
  );
});
var internal_default3 = InternalButton;

export {
  arrow_default,
  TabTrap,
  getAllFocusables,
  getFirstFocusable,
  getLastFocusable,
  focus_lock_default,
  KeyCode,
  PopoverBody,
  PopoverContainer,
  Portal,
  Transition,
  Tooltip,
  ButtonContext,
  defaultValue,
  SingleTabStopNavigationContext,
  useSingleTabStopNavigation,
  SingleTabStopNavigationProvider,
  useHiddenDescription,
  useDOMAttribute,
  useEffectOnUpdate,
  usePerformanceMarks,
  checkSafeUrl,
  styles_css_default4 as styles_css_default,
  InternalButton,
  internal_default3 as internal_default
};
//# sourceMappingURL=chunk-KFOOYN5R.js.map
