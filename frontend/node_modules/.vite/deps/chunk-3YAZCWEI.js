import {
  findUpUntil,
  nodeContains
} from "./chunk-TACQRHRS.js";
import {
  __awaiter
} from "./chunk-FA3WS4TG.js";
import {
  require_react
} from "./chunk-NNXGX6WR.js";
import {
  __commonJS,
  __toESM
} from "./chunk-WOOG5QLI.js";

// ../node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "../node_modules/balanced-match/index.js"(exports, module) {
    "use strict";
    module.exports = balanced2;
    function balanced2(a, b, str) {
      if (a instanceof RegExp) a = maybeMatch(a, str);
      if (b instanceof RegExp) b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced2.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// ../node_modules/@cloudscape-design/components/internal/analytics/index.js
var FunnelMetrics = {
  funnelStart() {
    return "";
  },
  funnelError() {
  },
  funnelComplete() {
  },
  funnelSuccessful() {
  },
  funnelCancelled() {
  },
  funnelChange() {
  },
  funnelStepStart() {
  },
  funnelStepComplete() {
  },
  funnelStepNavigation() {
  },
  funnelStepError() {
  },
  funnelStepChange() {
  },
  funnelSubStepStart() {
  },
  funnelSubStepComplete() {
  },
  funnelSubStepError() {
  },
  helpPanelInteracted() {
  },
  externalLinkInteracted() {
  }
};
var PerformanceMetrics = {
  tableInteraction() {
  },
  taskCompletionData() {
  },
  modalPerformanceData() {
  }
};
var ComponentMetrics = {
  componentMounted() {
    return "";
  },
  componentUpdated() {
  }
};

// ../node_modules/@cloudscape-design/components/internal/utils/dom.js
var import_balanced_match = __toESM(require_balanced_match());
function isContainingBlock(element) {
  var _a;
  const computedStyle = getComputedStyle(element);
  return !!computedStyle.transform && computedStyle.transform !== "none" || !!computedStyle.perspective && computedStyle.perspective !== "none" || !!computedStyle.containerType && computedStyle.containerType !== "normal" || ((_a = computedStyle.contain) === null || _a === void 0 ? void 0 : _a.split(" ").some((s) => ["layout", "paint", "strict", "content"].includes(s)));
}
function getContainingBlock(startElement) {
  if (!startElement.parentElement) {
    return null;
  }
  return findUpUntil(startElement.parentElement, isContainingBlock);
}
function findUpUntilMultiple({ startElement, tests }) {
  const keys = Object.keys(tests);
  const elements = {};
  let current = startElement;
  while (current && Object.keys(elements).length < keys.length) {
    current = current.parentElement;
    while (current && !isHTMLElement(current)) {
      current = current.parentElement;
    }
    for (const key of keys) {
      if (!elements[key] && current && tests[key](current)) {
        elements[key] = current;
      }
    }
  }
  return elements;
}
function isNode(target) {
  return target instanceof Node || target !== null && typeof target === "object" && "nodeType" in target && typeof target.nodeType === "number" && "nodeName" in target && typeof target.nodeName === "string" && "parentNode" in target && typeof target.parentNode === "object";
}
function isHTMLElement(target) {
  return target instanceof HTMLElement || isNode(target) && target.nodeType === Node.ELEMENT_NODE && "style" in target && typeof target.style === "object" && typeof target.ownerDocument === "object" && !isSVGElement(target);
}
function isSVGElement(target) {
  return target instanceof SVGElement || isNode(target) && target.nodeType === Node.ELEMENT_NODE && "ownerSVGElement" in target && typeof target.ownerSVGElement === "object";
}

// ../node_modules/@cloudscape-design/components/internal/utils/node-belongs.js
function nodeBelongs(container, target) {
  var _a;
  if (!isNode(target)) {
    return false;
  }
  const portal = findUpUntil(target, (node) => node === container || isHTMLElement(node) && !!node.dataset.awsuiReferrerId);
  if (portal && portal === container) {
    return true;
  }
  const referrer = isHTMLElement(portal) ? document.getElementById((_a = portal.dataset.awsuiReferrerId) !== null && _a !== void 0 ? _a : "") : null;
  return referrer ? nodeContains(container, referrer) : nodeContains(container, target);
}

// ../node_modules/@cloudscape-design/components/internal/analytics/selectors.js
var DATA_ATTR_FUNNEL = "data-analytics-funnel";
var DATA_ATTR_FUNNEL_INTERACTION_ID = `${DATA_ATTR_FUNNEL}-interaction-id`;
var DATA_ATTR_FUNNEL_KEY = `${DATA_ATTR_FUNNEL}-key`;
var DATA_ATTR_FUNNEL_VALUE = `${DATA_ATTR_FUNNEL}-value`;
var DATA_ATTR_FUNNEL_STEP = `${DATA_ATTR_FUNNEL}-step`;
var DATA_ATTR_FUNNEL_SUBSTEP = `${DATA_ATTR_FUNNEL}-substep`;
var DATA_ATTR_RESOURCE_TYPE = `${DATA_ATTR_FUNNEL}-resource-type`;
var DATA_ATTR_FIELD_LABEL = "data-analytics-field-label";
var DATA_ATTR_FIELD_ERROR = "data-analytics-field-error";
var FUNNEL_KEY_FUNNEL_NAME = "funnel-name";
var FUNNEL_KEY_SUBSTEP_NAME = "substep-name";
var getFunnelNameSelector = () => `[${DATA_ATTR_FUNNEL_KEY}="${FUNNEL_KEY_FUNNEL_NAME}"]`;
var getFunnelValueSelector = (value) => `[${DATA_ATTR_FUNNEL_VALUE}="${value}"]`;
var getSubStepAllSelector = () => `[${DATA_ATTR_FUNNEL_SUBSTEP}]`;
var getSubStepSelector = (subStepId) => `[${DATA_ATTR_FUNNEL_SUBSTEP}="${subStepId}"]`;
var getSubStepNameSelector = (subStepId) => [subStepId ? getSubStepSelector(subStepId) : "", `[${DATA_ATTR_FUNNEL_KEY}="${FUNNEL_KEY_SUBSTEP_NAME}"]`].join(" ");
var getFieldSlotSeletor = (id) => id ? `[id="${id}"]` : void 0;
var getTextFromSelector = (selector) => {
  var _a, _b;
  return selector ? (_b = (_a = document.querySelector(selector)) === null || _a === void 0 ? void 0 : _a.textContent) === null || _b === void 0 ? void 0 : _b.trim() : void 0;
};

// ../node_modules/@cloudscape-design/components/internal/analytics/context/analytics-context.js
var import_react = __toESM(require_react());
var FunnelContext = (0, import_react.createContext)({
  funnelInteractionId: void 0,
  funnelNameSelector: getFunnelNameSelector(),
  setFunnelInteractionId: () => {
  },
  funnelType: "single-page",
  optionalStepNumbers: [],
  totalFunnelSteps: 0,
  funnelSubmit: () => {
  },
  funnelCancel: () => {
  },
  submissionAttempt: 0,
  funnelNextOrSubmitAttempt: () => {
  },
  funnelState: { current: "default" },
  errorCount: { current: 0 },
  loadingButtonCount: { current: 0 },
  latestFocusCleanupFunction: { current: void 0 },
  isInFunnel: false,
  wizardCount: { current: 0 }
});
var FunnelStepContext = (0, import_react.createContext)({
  stepNameSelector: "",
  stepNumber: 0,
  subStepCount: { current: 0 },
  isInStep: false,
  funnelInteractionId: void 0,
  onStepChange: () => {
  },
  subStepConfiguration: { current: /* @__PURE__ */ new Map() }
});
var FunnelSubStepContext = (0, import_react.createContext)({
  subStepId: "",
  subStepSelector: "",
  subStepNameSelector: "",
  subStepRef: { current: null },
  isNestedSubStep: false,
  mousePressed: { current: false },
  isFocusedSubStep: { current: false },
  focusCleanupFunction: { current: void 0 }
});
var FunnelNameSelectorContext = (0, import_react.createContext)(void 0);

// ../node_modules/@cloudscape-design/components/internal/analytics/hooks/use-funnel.js
var import_react2 = __toESM(require_react());
var useFunnelSubStep = () => {
  const context = (0, import_react2.useContext)(FunnelSubStepContext);
  const { funnelInteractionId, funnelIdentifier, funnelState, latestFocusCleanupFunction } = useFunnel();
  const { stepNumber, stepIdentifier, stepNameSelector, subStepConfiguration } = useFunnelStep();
  const { subStepIdentifier, subStepId, subStepSelector, subStepNameSelector, subStepRef, isNestedSubStep, mousePressed, isFocusedSubStep, focusCleanupFunction } = context;
  if (isNestedSubStep) {
    return context;
  }
  const onFocus = (event) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b, _c, _d;
    const element = event.target;
    yield new Promise((r) => setTimeout(r, 1));
    if (document.activeElement !== element) {
      return;
    }
    if (isFocusedSubStep.current) {
      return;
    }
    isFocusedSubStep.current = true;
    if (funnelInteractionId && subStepId) {
      (_a = latestFocusCleanupFunction.current) === null || _a === void 0 ? void 0 : _a.call(latestFocusCleanupFunction);
      const subStepName = getTextFromSelector(subStepNameSelector);
      const stepName = getTextFromSelector(stepNameSelector);
      const subStepNumber = (_d = (_c = (_b = subStepConfiguration.current) === null || _b === void 0 ? void 0 : _b.get(stepNumber)) === null || _c === void 0 ? void 0 : _c.find((step) => step.name === subStepName)) === null || _d === void 0 ? void 0 : _d.number;
      FunnelMetrics.funnelSubStepStart({
        funnelIdentifier,
        funnelInteractionId,
        subStepIdentifier,
        subStepSelector,
        subStepNameSelector,
        subStepName,
        subStepNumber,
        stepIdentifier,
        stepNumber,
        stepName,
        stepNameSelector,
        subStepAllSelector: getSubStepAllSelector()
      });
      let cleanupFunctionHasBeenRun = false;
      focusCleanupFunction.current = () => {
        var _a2, _b2, _c2;
        if (cleanupFunctionHasBeenRun) {
          return;
        }
        cleanupFunctionHasBeenRun = true;
        const subStepNumber2 = (_c2 = (_b2 = (_a2 = subStepConfiguration.current) === null || _a2 === void 0 ? void 0 : _a2.get(stepNumber)) === null || _b2 === void 0 ? void 0 : _b2.find((s) => s.name === subStepName)) === null || _c2 === void 0 ? void 0 : _c2.number;
        if (funnelState.current !== "cancelled") {
          FunnelMetrics.funnelSubStepComplete({
            funnelIdentifier,
            funnelInteractionId,
            subStepIdentifier,
            subStepSelector,
            subStepNameSelector,
            subStepName,
            subStepNumber: subStepNumber2,
            stepIdentifier,
            stepNumber,
            stepName,
            stepNameSelector,
            subStepAllSelector: getSubStepAllSelector()
          });
        }
      };
      latestFocusCleanupFunction.current = focusCleanupFunction.current;
    }
  });
  const onBlur = (event) => {
    var _a;
    if (mousePressed.current) {
      return;
    }
    if (!subStepRef.current || !event.relatedTarget || !nodeBelongs(subStepRef.current, event.relatedTarget)) {
      isFocusedSubStep.current = false;
      if (funnelInteractionId && subStepId && funnelState.current !== "cancelled") {
        (_a = focusCleanupFunction.current) === null || _a === void 0 ? void 0 : _a.call(focusCleanupFunction);
      }
    }
  };
  const funnelSubStepProps = funnelInteractionId ? {
    [DATA_ATTR_FUNNEL_SUBSTEP]: subStepId,
    onFocus,
    onBlur
  } : {};
  return Object.assign({ funnelSubStepProps }, context);
};
var useFunnelStep = () => {
  const context = (0, import_react2.useContext)(FunnelStepContext);
  return context;
};
var useFunnel = () => {
  const context = (0, import_react2.useContext)(FunnelContext);
  const funnelProps = context.funnelInteractionId ? {
    [DATA_ATTR_FUNNEL_INTERACTION_ID]: context.funnelInteractionId
  } : {};
  return Object.assign({ funnelProps }, context);
};

export {
  FunnelMetrics,
  PerformanceMetrics,
  ComponentMetrics,
  isContainingBlock,
  getContainingBlock,
  findUpUntilMultiple,
  isHTMLElement,
  isSVGElement,
  nodeBelongs,
  DATA_ATTR_FUNNEL_KEY,
  DATA_ATTR_FUNNEL_VALUE,
  DATA_ATTR_RESOURCE_TYPE,
  DATA_ATTR_FIELD_LABEL,
  DATA_ATTR_FIELD_ERROR,
  FUNNEL_KEY_FUNNEL_NAME,
  FUNNEL_KEY_SUBSTEP_NAME,
  getFunnelValueSelector,
  getSubStepAllSelector,
  getSubStepSelector,
  getSubStepNameSelector,
  getFieldSlotSeletor,
  getTextFromSelector,
  FunnelSubStepContext,
  FunnelNameSelectorContext,
  useFunnelSubStep,
  useFunnelStep,
  useFunnel
};
//# sourceMappingURL=chunk-3YAZCWEI.js.map
