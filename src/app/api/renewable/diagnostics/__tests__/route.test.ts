/**
 * Integration tests for Renewable Energy Diagnostics API
 * 
 * Tests the /api/renewable/diagnostics endpoint functionality including:
 * - Authentication requirements
 * - Diagnostic result format
 * - CloudWatch link generation
 * - Error handling
 * 
 * Note: These tests verify the API logic without requiring full Next.js runtime.
 * For full end-to-end testing, use the test scripts in /tests directory.
 */

import { OrchestratorDiagnostics, DiagnosticResult } from '../../../../../../amplify/functions/agents/diagnostics/orchestratorDiagnostics';

// Mock AWS SDK
jest.mock('@aws-sdk/client-lambda');

describe('Renewable Diagnostics API Logic', () => {
  let diagnostics: OrchestratorDiagnostics;

  beforeEach(() => {
    jest.clearAllMocks();

    // Set up environment variables
    process.env.AWS_REGION = 'us-west-2';
    process.env.RENEWABLE_ORCHESTRATOR_FUNCTION_NAME = 'test-orchestrator';
    process.env.RENEWABLE_TERRAIN_TOOL_FUNCTION_NAME = 'test-terrain';
    process.env.RENEWABLE_LAYOUT_TOOL_FUNCTION_NAME = 'test-layout';
    process.env.RENEWABLE_SIMULATION_TOOL_FUNCTION_NAME = 'test-simulation';
    process.env.RENEWABLE_REPORT_TOOL_FUNCTION_NAME = 'test-report';

    diagnostics = new OrchestratorDiagnostics('us-west-2');
  });

  afterEach(() => {
    // Clean up environment variables
    delete process.env.RENEWABLE_ORCHESTRATOR_FUNCTION_NAME;
    delete process.env.RENEWABLE_TERRAIN_TOOL_FUNCTION_NAME;
    delete process.env.RENEWABLE_LAYOUT_TOOL_FUNCTION_NAME;
    delete process.env.RENEWABLE_SIMULATION_TOOL_FUNCTION_NAME;
    delete process.env.RENEWABLE_REPORT_TOOL_FUNCTION_NAME;
  });

describe('Diagnostic API Response Format', () => {
    it('should validate diagnostic result structure', () => {
      const result: DiagnosticResult = {
        step: 'Test Step',
        success: true,
        details: { test: 'data' },
        timestamp: Date.now(),
        duration: 100,
      };

      expect(result).toHaveProperty('step');
      expect(result).toHaveProperty('success');
      expect(result).toHaveProperty('details');
      expect(result).toHaveProperty('timestamp');
      expect(result).toHaveProperty('duration');
    });

    it('should include error and recommendations for failed checks', () => {
      const result: DiagnosticResult = {
        step: 'Failed Check',
        success: false,
        details: {},
        error: 'Something went wrong',
        timestamp: Date.now(),
        duration: 50,
        recommendations: ['Fix this', 'Try that'],
      };

      expect(result.success).toBe(false);
      expect(result.error).toBeDefined();
      expect(result.recommendations).toHaveLength(2);
    });
  });

  describe('Environment Variable Checks', () => {
    it('should check all required environment variables', () => {
      const result = diagnostics.checkEnvironmentVariables();

      expect(result.step).toBe('Check Environment Variables');
      expect(result.success).toBe(true);
      expect(result.details.setVariables).toHaveProperty('RENEWABLE_ORCHESTRATOR_FUNCTION_NAME');
      expect(result.details.setVariables).toHaveProperty('RENEWABLE_TERRAIN_TOOL_FUNCTION_NAME');
      expect(result.details.setVariables).toHaveProperty('AWS_REGION');
    });

    it('should detect missing environment variables', () => {
      delete process.env.RENEWABLE_ORCHESTRATOR_FUNCTION_NAME;
      delete process.env.RENEWABLE_TERRAIN_TOOL_FUNCTION_NAME;

      const result = diagnostics.checkEnvironmentVariables();

      expect(result.success).toBe(false);
      expect(result.details.missingVariables).toContain('RENEWABLE_ORCHESTRATOR_FUNCTION_NAME');
      expect(result.details.missingVariables).toContain('RENEWABLE_TERRAIN_TOOL_FUNCTION_NAME');
      expect(result.recommendations).toBeDefined();
      expect(result.recommendations!.length).toBeGreaterThan(0);
    });

    it('should provide recommendations for missing variables', () => {
      delete process.env.RENEWABLE_ORCHESTRATOR_FUNCTION_NAME;

      const result = diagnostics.checkEnvironmentVariables();

      expect(result.recommendations).toContain('CRITICAL: Orchestrator function name must be set for renewable features to work');
    });
  });

  describe('CloudWatch Link Generation', () => {
    it('should generate correct CloudWatch link format', () => {
      const functionName = 'test-function';
      const region = 'us-west-2';
      const encodedName = encodeURIComponent(functionName);
      
      const expectedLink = `https://${region}.console.aws.amazon.com/cloudwatch/home?region=${region}#logsV2:log-groups/log-group/$252Faws$252Flambda$252F${encodedName}`;

      // This tests the link format that should be generated by the API
      expect(expectedLink).toContain('console.aws.amazon.com/cloudwatch');
      expect(expectedLink).toContain(region);
      expect(expectedLink).toContain(encodedName);
    });
  });

  describe('Summary Statistics', () => {
    it('should calculate summary statistics correctly', () => {
      const results: DiagnosticResult[] = [
        {
          step: 'Check 1',
          success: true,
          details: {},
          timestamp: Date.now(),
          duration: 50,
        },
        {
          step: 'Check 2',
          success: false,
          details: {},
          error: 'Failed',
          timestamp: Date.now(),
          duration: 100,
        },
        {
          step: 'Check 3',
          success: true,
          details: {},
          timestamp: Date.now(),
          duration: 75,
        },
      ];

      const summary = {
        total: results.length,
        passed: results.filter(r => r.success).length,
        failed: results.filter(r => !r.success).length,
        totalDuration: results.reduce((sum, r) => sum + (r.duration || 0), 0),
      };

      expect(summary.total).toBe(3);
      expect(summary.passed).toBe(2);
      expect(summary.failed).toBe(1);
      expect(summary.totalDuration).toBe(225);
    });
  });

  describe('Overall Status Determination', () => {
    it('should return healthy when all checks pass', () => {
      const results: DiagnosticResult[] = [
        { step: 'Check 1', success: true, details: {}, timestamp: Date.now(), duration: 10 },
        { step: 'Check 2', success: true, details: {}, timestamp: Date.now(), duration: 20 },
      ];

      const allPassed = results.every(r => r.success);
      const anyFailed = results.some(r => !r.success);
      const status = allPassed ? 'healthy' : anyFailed ? 'unhealthy' : 'degraded';

      expect(status).toBe('healthy');
    });

    it('should return unhealthy when any check fails', () => {
      const results: DiagnosticResult[] = [
        { step: 'Check 1', success: true, details: {}, timestamp: Date.now(), duration: 10 },
        { step: 'Check 2', success: false, details: {}, error: 'Failed', timestamp: Date.now(), duration: 20 },
      ];

      const allPassed = results.every(r => r.success);
      const anyFailed = results.some(r => !r.success);
      const status = allPassed ? 'healthy' : anyFailed ? 'unhealthy' : 'degraded';

      expect(status).toBe('unhealthy');
    });
  });

  describe('Recommendation Deduplication', () => {
    it('should remove duplicate recommendations', () => {
      const results: DiagnosticResult[] = [
        {
          step: 'Check 1',
          success: false,
          details: {},
          error: 'Error 1',
          timestamp: Date.now(),
          duration: 10,
          recommendations: ['Fix A', 'Fix B'],
        },
        {
          step: 'Check 2',
          success: false,
          details: {},
          error: 'Error 2',
          timestamp: Date.now(),
          duration: 20,
          recommendations: ['Fix B', 'Fix C'],
        },
      ];

      const allRecommendations = results
        .filter(r => r.recommendations && r.recommendations.length > 0)
        .flatMap(r => r.recommendations || []);

      const uniqueRecommendations = Array.from(new Set(allRecommendations));

      expect(allRecommendations).toHaveLength(4); // 2 + 2
      expect(uniqueRecommendations).toHaveLength(3); // A, B, C (B deduplicated)
      expect(uniqueRecommendations).toContain('Fix A');
      expect(uniqueRecommendations).toContain('Fix B');
      expect(uniqueRecommendations).toContain('Fix C');
    });
  });

  describe('Next Steps Logic', () => {
    it('should provide operational message for healthy system', () => {
      const overallStatus = 'healthy';
      const results: DiagnosticResult[] = [];

      const nextSteps: string[] = [];
      if (overallStatus === 'healthy') {
        nextSteps.push('All systems operational - orchestrator is ready to use');
        nextSteps.push('You can now perform terrain analysis queries');
      }

      expect(nextSteps).toContain('All systems operational - orchestrator is ready to use');
      expect(nextSteps).toContain('You can now perform terrain analysis queries');
    });

    it('should provide deployment steps for missing orchestrator', () => {
      const results: DiagnosticResult[] = [
        {
          step: 'Check Orchestrator Exists',
          success: false,
          details: {},
          error: 'ResourceNotFoundException: Function not found',
          timestamp: Date.now(),
          duration: 100,
        },
      ];

      const existsCheck = results.find(r => r.step === 'Check Orchestrator Exists');
      const nextSteps: string[] = [];

      if (existsCheck && !existsCheck.success && existsCheck.error?.includes('ResourceNotFoundException')) {
        nextSteps.push('1. Deploy the orchestrator Lambda function');
        nextSteps.push('2. Run: npx ampx sandbox');
        nextSteps.push('3. Wait for deployment to complete (may take 5-10 minutes)');
        nextSteps.push('4. Run diagnostics again to verify deployment');
      }

      expect(nextSteps.some(step => step.includes('Deploy the orchestrator'))).toBe(true);
      expect(nextSteps.some(step => step.includes('npx ampx sandbox'))).toBe(true);
    });

    it('should provide environment variable steps for config issues', () => {
      const results: DiagnosticResult[] = [
        {
          step: 'Check Environment Variables',
          success: false,
          details: { missingVariables: ['RENEWABLE_ORCHESTRATOR_FUNCTION_NAME'] },
          error: 'Missing variables',
          timestamp: Date.now(),
          duration: 10,
        },
      ];

      const envCheck = results.find(r => r.step === 'Check Environment Variables');
      const nextSteps: string[] = [];

      if (envCheck && !envCheck.success) {
        nextSteps.push('1. Fix environment variable configuration in amplify/backend.ts');
        nextSteps.push('2. Run: npx ampx sandbox to redeploy with correct configuration');
        nextSteps.push('3. Wait for deployment to complete');
        nextSteps.push('4. Run diagnostics again to verify');
      }

      expect(nextSteps.some(step => step.includes('environment variable'))).toBe(true);
      expect(nextSteps.some(step => step.includes('amplify/backend.ts'))).toBe(true);
    });
  });
});
