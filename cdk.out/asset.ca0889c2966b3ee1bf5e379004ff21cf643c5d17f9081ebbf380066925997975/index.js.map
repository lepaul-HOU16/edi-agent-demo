{
  "version": 3,
  "sources": ["../../../lambda-functions/chat-sessions/handler.ts"],
  "sourcesContent": ["/**\n * ChatSession Lambda Handler\n * \n * Handles all ChatSession CRUD operations for the REST API migration.\n * Replaces Amplify GraphQL ChatSession model operations.\n */\n\nimport { DynamoDBClient } from '@aws-sdk/client-dynamodb';\nimport {\n  DynamoDBDocumentClient,\n  PutCommand,\n  GetCommand,\n  QueryCommand,\n  DeleteCommand,\n  UpdateCommand,\n  ScanCommand,\n} from '@aws-sdk/lib-dynamodb';\nimport { APIGatewayProxyEventV2, APIGatewayProxyResultV2 } from 'aws-lambda';\nimport { randomUUID } from 'crypto';\n\n// Initialize DynamoDB client\nconst client = new DynamoDBClient({});\nconst docClient = DynamoDBDocumentClient.from(client);\n\nconst CHAT_SESSION_TABLE = process.env.CHAT_SESSION_TABLE!;\nconst CHAT_MESSAGE_TABLE = process.env.CHAT_MESSAGE_TABLE!;\n\n/**\n * ChatSession interface matching Amplify schema\n */\ninterface ChatSession {\n  id: string;\n  name?: string;\n  owner: string;\n  workSteps?: any[];\n  linkedCollectionId?: string;\n  collectionContext?: any;\n  dataAccessLog?: any[];\n  createdAt: string;\n  updatedAt: string;\n}\n\n/**\n * Extract user ID from JWT claims or custom authorizer context\n */\nfunction getUserId(event: APIGatewayProxyEventV2): string {\n  // Try JWT claims first (standard Cognito authorizer)\n  const claims = event.requestContext.authorizer?.jwt?.claims;\n  if (claims && claims.sub) {\n    return claims.sub as string;\n  }\n  \n  // Try custom Lambda authorizer context (mock auth or custom authorizer)\n  const authContext = event.requestContext.authorizer as any;\n  if (authContext && authContext.lambda) {\n    // Lambda authorizer puts context in 'lambda' property\n    if (authContext.lambda.userId) {\n      return authContext.lambda.userId as string;\n    }\n  }\n  \n  // Try direct context (fallback)\n  if (authContext && authContext.userId) {\n    return authContext.userId as string;\n  }\n  \n  throw new Error('Unauthorized: No user ID in token');\n}\n\n/**\n * Create CORS headers\n */\nfunction getCorsHeaders() {\n  return {\n    'Access-Control-Allow-Origin': '*',\n    'Access-Control-Allow-Headers': 'Content-Type,Authorization',\n    'Access-Control-Allow-Methods': 'GET,POST,PUT,PATCH,DELETE,OPTIONS',\n  };\n}\n\n/**\n * Create success response\n */\nfunction successResponse(data: any, statusCode: number = 200): APIGatewayProxyResultV2 {\n  return {\n    statusCode,\n    headers: getCorsHeaders(),\n    body: JSON.stringify(data),\n  };\n}\n\n/**\n * Create error response\n */\nfunction errorResponse(message: string, statusCode: number = 500): APIGatewayProxyResultV2 {\n  return {\n    statusCode,\n    headers: getCorsHeaders(),\n    body: JSON.stringify({ error: message }),\n  };\n}\n\n/**\n * POST /api/chat/sessions - Create new session\n */\nasync function createSession(event: APIGatewayProxyEventV2): Promise<APIGatewayProxyResultV2> {\n  try {\n    const userId = getUserId(event);\n    const body = event.body ? JSON.parse(event.body) : {};\n\n    const now = new Date().toISOString();\n    const session: ChatSession = {\n      id: randomUUID(),\n      owner: userId,\n      name: body.name,\n      workSteps: body.workSteps,\n      linkedCollectionId: body.linkedCollectionId,\n      collectionContext: body.collectionContext,\n      dataAccessLog: body.dataAccessLog,\n      createdAt: now,\n      updatedAt: now,\n    };\n\n    await docClient.send(\n      new PutCommand({\n        TableName: CHAT_SESSION_TABLE,\n        Item: session,\n      })\n    );\n\n    return successResponse({ data: session }, 201);\n  } catch (error: any) {\n    console.error('Error creating session:', error);\n    return errorResponse(error.message || 'Failed to create session', 500);\n  }\n}\n\n/**\n * GET /api/chat/sessions - List user's sessions\n */\nasync function listSessions(event: APIGatewayProxyEventV2): Promise<APIGatewayProxyResultV2> {\n  try {\n    const userId = getUserId(event);\n    const queryParams = event.queryStringParameters || {};\n    \n    // Support pagination\n    const limit = queryParams.limit ? parseInt(queryParams.limit) : 50;\n    const nextToken = queryParams.nextToken;\n\n    // Query by owner (GSI required on owner field)\n    const result = await docClient.send(\n      new QueryCommand({\n        TableName: CHAT_SESSION_TABLE,\n        IndexName: 'byOwner', // GSI on owner field\n        KeyConditionExpression: '#owner = :owner',\n        ExpressionAttributeNames: {\n          '#owner': 'owner',\n        },\n        ExpressionAttributeValues: {\n          ':owner': userId,\n        },\n        Limit: limit,\n        ExclusiveStartKey: nextToken ? JSON.parse(Buffer.from(nextToken, 'base64').toString()) : undefined,\n        ScanIndexForward: false, // Most recent first\n      })\n    );\n\n    const response: any = {\n      data: result.Items || [],\n    };\n\n    if (result.LastEvaluatedKey) {\n      response.nextToken = Buffer.from(JSON.stringify(result.LastEvaluatedKey)).toString('base64');\n    }\n\n    return successResponse(response);\n  } catch (error: any) {\n    console.error('Error listing sessions:', error);\n    return errorResponse(error.message || 'Failed to list sessions', 500);\n  }\n}\n\n/**\n * GET /api/chat/sessions/{id} - Get session details\n */\nasync function getSession(event: APIGatewayProxyEventV2): Promise<APIGatewayProxyResultV2> {\n  try {\n    const userId = getUserId(event);\n    const sessionId = event.pathParameters?.id;\n\n    if (!sessionId) {\n      return errorResponse('Session ID is required', 400);\n    }\n\n    const result = await docClient.send(\n      new GetCommand({\n        TableName: CHAT_SESSION_TABLE,\n        Key: { id: sessionId },\n      })\n    );\n\n    if (!result.Item) {\n      return errorResponse('Session not found', 404);\n    }\n\n    // Verify ownership\n    if (result.Item.owner !== userId) {\n      return errorResponse('Unauthorized: You do not own this session', 403);\n    }\n\n    return successResponse({ data: result.Item });\n  } catch (error: any) {\n    console.error('Error getting session:', error);\n    return errorResponse(error.message || 'Failed to get session', 500);\n  }\n}\n\n/**\n * PATCH /api/chat/sessions/{id} - Update session\n */\nasync function updateSession(event: APIGatewayProxyEventV2): Promise<APIGatewayProxyResultV2> {\n  try {\n    const userId = getUserId(event);\n    const sessionId = event.pathParameters?.id;\n    const body = event.body ? JSON.parse(event.body) : {};\n\n    if (!sessionId) {\n      return errorResponse('Session ID is required', 400);\n    }\n\n    // First, verify ownership\n    const existing = await docClient.send(\n      new GetCommand({\n        TableName: CHAT_SESSION_TABLE,\n        Key: { id: sessionId },\n      })\n    );\n\n    if (!existing.Item) {\n      return errorResponse('Session not found', 404);\n    }\n\n    if (existing.Item.owner !== userId) {\n      return errorResponse('Unauthorized: You do not own this session', 403);\n    }\n\n    // Build update expression\n    const updateExpressions: string[] = [];\n    const expressionAttributeNames: Record<string, string> = {};\n    const expressionAttributeValues: Record<string, any> = {};\n\n    const updatableFields = ['name', 'workSteps', 'linkedCollectionId', 'collectionContext', 'dataAccessLog'];\n    \n    updatableFields.forEach((field) => {\n      if (body[field] !== undefined) {\n        updateExpressions.push(`#${field} = :${field}`);\n        expressionAttributeNames[`#${field}`] = field;\n        expressionAttributeValues[`:${field}`] = body[field];\n      }\n    });\n\n    // Always update updatedAt\n    updateExpressions.push('#updatedAt = :updatedAt');\n    expressionAttributeNames['#updatedAt'] = 'updatedAt';\n    expressionAttributeValues[':updatedAt'] = new Date().toISOString();\n\n    if (updateExpressions.length === 1) {\n      // Only updatedAt, nothing to update\n      return successResponse({ data: existing.Item });\n    }\n\n    const result = await docClient.send(\n      new UpdateCommand({\n        TableName: CHAT_SESSION_TABLE,\n        Key: { id: sessionId },\n        UpdateExpression: `SET ${updateExpressions.join(', ')}`,\n        ExpressionAttributeNames: expressionAttributeNames,\n        ExpressionAttributeValues: expressionAttributeValues,\n        ReturnValues: 'ALL_NEW',\n      })\n    );\n\n    return successResponse({ data: result.Attributes });\n  } catch (error: any) {\n    console.error('Error updating session:', error);\n    return errorResponse(error.message || 'Failed to update session', 500);\n  }\n}\n\n/**\n * DELETE /api/chat/sessions/{id} - Delete session\n */\nasync function deleteSession(event: APIGatewayProxyEventV2): Promise<APIGatewayProxyResultV2> {\n  try {\n    const userId = getUserId(event);\n    const sessionId = event.pathParameters?.id;\n\n    if (!sessionId) {\n      return errorResponse('Session ID is required', 400);\n    }\n\n    // First, verify ownership\n    const existing = await docClient.send(\n      new GetCommand({\n        TableName: CHAT_SESSION_TABLE,\n        Key: { id: sessionId },\n      })\n    );\n\n    if (!existing.Item) {\n      return errorResponse('Session not found', 404);\n    }\n\n    if (existing.Item.owner !== userId) {\n      return errorResponse('Unauthorized: You do not own this session', 403);\n    }\n\n    // Delete the session\n    await docClient.send(\n      new DeleteCommand({\n        TableName: CHAT_SESSION_TABLE,\n        Key: { id: sessionId },\n      })\n    );\n\n    // Note: Messages are not deleted automatically (they have their own lifecycle)\n    // This matches Amplify behavior where messages can exist without a session\n\n    return successResponse({ data: { id: sessionId, deleted: true } });\n  } catch (error: any) {\n    console.error('Error deleting session:', error);\n    return errorResponse(error.message || 'Failed to delete session', 500);\n  }\n}\n\n/**\n * GET /api/chat/sessions/{id}/messages - Get session messages\n */\nasync function getSessionMessages(event: APIGatewayProxyEventV2): Promise<APIGatewayProxyResultV2> {\n  try {\n    const userId = getUserId(event);\n    const sessionId = event.pathParameters?.id;\n    const queryParams = event.queryStringParameters || {};\n\n    if (!sessionId) {\n      return errorResponse('Session ID is required', 400);\n    }\n\n    // First, verify session ownership\n    const session = await docClient.send(\n      new GetCommand({\n        TableName: CHAT_SESSION_TABLE,\n        Key: { id: sessionId },\n      })\n    );\n\n    if (!session.Item) {\n      return errorResponse('Session not found', 404);\n    }\n\n    if (session.Item.owner !== userId) {\n      return errorResponse('Unauthorized: You do not own this session', 403);\n    }\n\n    // Query messages by chatSessionId (GSI required)\n    const limit = queryParams.limit ? parseInt(queryParams.limit) : 100;\n    const nextToken = queryParams.nextToken;\n\n    const result = await docClient.send(\n      new QueryCommand({\n        TableName: CHAT_MESSAGE_TABLE,\n        IndexName: 'chatMessagesByChatSessionIdAndCreatedAt', // Actual GSI name from Amplify\n        KeyConditionExpression: 'chatSessionId = :sessionId',\n        ExpressionAttributeValues: {\n          ':sessionId': sessionId,\n        },\n        Limit: limit,\n        ExclusiveStartKey: nextToken ? JSON.parse(Buffer.from(nextToken, 'base64').toString()) : undefined,\n        ScanIndexForward: true, // Chronological order\n      })\n    );\n\n    const response: any = {\n      data: result.Items || [],\n    };\n\n    if (result.LastEvaluatedKey) {\n      response.nextToken = Buffer.from(JSON.stringify(result.LastEvaluatedKey)).toString('base64');\n    }\n\n    return successResponse(response);\n  } catch (error: any) {\n    console.error('Error getting session messages:', error);\n    return errorResponse(error.message || 'Failed to get session messages', 500);\n  }\n}\n\n/**\n * Main Lambda handler\n */\nexport async function handler(event: APIGatewayProxyEventV2): Promise<APIGatewayProxyResultV2> {\n  console.log('ChatSession handler invoked:', JSON.stringify(event, null, 2));\n\n  // Handle OPTIONS for CORS preflight\n  if (event.requestContext.http.method === 'OPTIONS') {\n    return {\n      statusCode: 200,\n      headers: getCorsHeaders(),\n      body: '',\n    };\n  }\n\n  try {\n    const method = event.requestContext.http.method;\n    const path = event.requestContext.http.path;\n\n    // Route to appropriate handler\n    if (method === 'POST' && path === '/api/chat/sessions') {\n      return await createSession(event);\n    } else if (method === 'GET' && path === '/api/chat/sessions') {\n      return await listSessions(event);\n    } else if (method === 'GET' && path.match(/^\\/api\\/chat\\/sessions\\/[^/]+$/)) {\n      return await getSession(event);\n    } else if (method === 'PATCH' && path.match(/^\\/api\\/chat\\/sessions\\/[^/]+$/)) {\n      return await updateSession(event);\n    } else if (method === 'DELETE' && path.match(/^\\/api\\/chat\\/sessions\\/[^/]+$/)) {\n      return await deleteSession(event);\n    } else if (method === 'GET' && path.match(/^\\/api\\/chat\\/sessions\\/[^/]+\\/messages$/)) {\n      return await getSessionMessages(event);\n    } else {\n      return errorResponse('Not found', 404);\n    }\n  } catch (error: any) {\n    console.error('Unhandled error:', error);\n    return errorResponse(error.message || 'Internal server error', 500);\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
